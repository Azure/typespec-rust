// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::{
    generated::xml_helpers::ColorsString, generated::xml_helpers::CountsInt32,
    generated::xml_helpers::ItemsSimpleModel,
};
use async_std::task::block_on;
use azure_core::{Model, RequestContent, Response, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use typespec_client_core::xml::to_xml;

/// Contains an array of models.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ModelWithArrayOfModel {
    #[serde(
        deserialize_with = "ItemsSimpleModel::unwrap",
        serialize_with = "ItemsSimpleModel::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub items: Option<Vec<SimpleModel>>,
}

/// Contains fields that are XML attributes.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ModelWithAttributes {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,

    #[serde(rename = "@id1", skip_serializing_if = "Option::is_none")]
    pub id1: Option<i32>,

    #[serde(rename = "@id2", skip_serializing_if = "Option::is_none")]
    pub id2: Option<String>,
}

/// Contains a dictionary of key value pairs.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ModelWithDictionary {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
}

/// Contains an array of models that's supposed to be sent/received as an empty XML element.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ModelWithEmptyArray {
    #[serde(
        deserialize_with = "ItemsSimpleModel::unwrap",
        serialize_with = "ItemsSimpleModel::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub items: Option<Vec<SimpleModel>>,
}

/// Uses encodedName instead of Xml.Name which is functionally equivalent.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
#[serde(rename = "ModelWithEncodedNamesSrc")]
pub struct ModelWithEncodedNames {
    #[serde(
        rename = "PossibleColors",
        deserialize_with = "ColorsString::unwrap",
        serialize_with = "ColorsString::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub colors: Option<Vec<String>>,

    #[serde(rename = "SimpleModelData", skip_serializing_if = "Option::is_none")]
    pub model_data: Option<SimpleModel>,
}

/// Contains an optional field.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ModelWithOptionalField {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub item: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<i32>,
}

/// Contains fields of wrapped and unwrapped arrays of primitive types that have different XML representations.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ModelWithRenamedArrays {
    #[serde(rename = "Colors", skip_serializing_if = "Option::is_none")]
    pub colors: Option<Vec<String>>,

    #[serde(
        rename = "Counts",
        deserialize_with = "CountsInt32::unwrap",
        serialize_with = "CountsInt32::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub counts: Option<Vec<i32>>,
}

/// Contains fields of the same type that have different XML representation.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
#[serde(rename = "ModelWithRenamedFieldsSrc")]
pub struct ModelWithRenamedFields {
    #[serde(rename = "InputData", skip_serializing_if = "Option::is_none")]
    pub input_data: Option<SimpleModel>,

    #[serde(rename = "OutputData", skip_serializing_if = "Option::is_none")]
    pub output_data: Option<SimpleModel>,
}

/// Contains fields of arrays of primitive types.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ModelWithSimpleArrays {
    #[serde(
        deserialize_with = "ColorsString::unwrap",
        serialize_with = "ColorsString::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub colors: Option<Vec<String>>,

    #[serde(
        deserialize_with = "CountsInt32::unwrap",
        serialize_with = "CountsInt32::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub counts: Option<Vec<i32>>,
}

/// Contains an attribute and text.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ModelWithText {
    #[serde(rename = "$text", skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,

    #[serde(rename = "@language", skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
}

/// Contains fields of wrapped and unwrapped arrays of primitive types.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ModelWithUnwrappedArray {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub colors: Option<Vec<String>>,

    #[serde(
        deserialize_with = "CountsInt32::unwrap",
        serialize_with = "CountsInt32::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub counts: Option<Vec<i32>>,
}

/// Contains fields of primitive types.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct SimpleModel {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub age: Option<i32>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl TryFrom<ModelWithArrayOfModel> for RequestContent<ModelWithArrayOfModel> {
    type Error = azure_core::Error;
    fn try_from(value: ModelWithArrayOfModel) -> Result<Self> {
        RequestContent::try_from(to_xml(&value)?)
    }
}

impl TryFrom<Response<ModelWithArrayOfModel>> for ModelWithArrayOfModel {
    type Error = azure_core::Error;
    fn try_from(value: Response<ModelWithArrayOfModel>) -> Result<Self> {
        let f = || value.into_body().xml::<ModelWithArrayOfModel>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<ModelWithAttributes> for RequestContent<ModelWithAttributes> {
    type Error = azure_core::Error;
    fn try_from(value: ModelWithAttributes) -> Result<Self> {
        RequestContent::try_from(to_xml(&value)?)
    }
}

impl TryFrom<Response<ModelWithAttributes>> for ModelWithAttributes {
    type Error = azure_core::Error;
    fn try_from(value: Response<ModelWithAttributes>) -> Result<Self> {
        let f = || value.into_body().xml::<ModelWithAttributes>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<ModelWithDictionary> for RequestContent<ModelWithDictionary> {
    type Error = azure_core::Error;
    fn try_from(value: ModelWithDictionary) -> Result<Self> {
        RequestContent::try_from(to_xml(&value)?)
    }
}

impl TryFrom<Response<ModelWithDictionary>> for ModelWithDictionary {
    type Error = azure_core::Error;
    fn try_from(value: Response<ModelWithDictionary>) -> Result<Self> {
        let f = || value.into_body().xml::<ModelWithDictionary>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<ModelWithEmptyArray> for RequestContent<ModelWithEmptyArray> {
    type Error = azure_core::Error;
    fn try_from(value: ModelWithEmptyArray) -> Result<Self> {
        RequestContent::try_from(to_xml(&value)?)
    }
}

impl TryFrom<Response<ModelWithEmptyArray>> for ModelWithEmptyArray {
    type Error = azure_core::Error;
    fn try_from(value: Response<ModelWithEmptyArray>) -> Result<Self> {
        let f = || value.into_body().xml::<ModelWithEmptyArray>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<ModelWithEncodedNames> for RequestContent<ModelWithEncodedNames> {
    type Error = azure_core::Error;
    fn try_from(value: ModelWithEncodedNames) -> Result<Self> {
        RequestContent::try_from(to_xml(&value)?)
    }
}

impl TryFrom<Response<ModelWithEncodedNames>> for ModelWithEncodedNames {
    type Error = azure_core::Error;
    fn try_from(value: Response<ModelWithEncodedNames>) -> Result<Self> {
        let f = || value.into_body().xml::<ModelWithEncodedNames>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<ModelWithOptionalField> for RequestContent<ModelWithOptionalField> {
    type Error = azure_core::Error;
    fn try_from(value: ModelWithOptionalField) -> Result<Self> {
        RequestContent::try_from(to_xml(&value)?)
    }
}

impl TryFrom<Response<ModelWithOptionalField>> for ModelWithOptionalField {
    type Error = azure_core::Error;
    fn try_from(value: Response<ModelWithOptionalField>) -> Result<Self> {
        let f = || value.into_body().xml::<ModelWithOptionalField>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<ModelWithRenamedArrays> for RequestContent<ModelWithRenamedArrays> {
    type Error = azure_core::Error;
    fn try_from(value: ModelWithRenamedArrays) -> Result<Self> {
        RequestContent::try_from(to_xml(&value)?)
    }
}

impl TryFrom<Response<ModelWithRenamedArrays>> for ModelWithRenamedArrays {
    type Error = azure_core::Error;
    fn try_from(value: Response<ModelWithRenamedArrays>) -> Result<Self> {
        let f = || value.into_body().xml::<ModelWithRenamedArrays>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<ModelWithRenamedFields> for RequestContent<ModelWithRenamedFields> {
    type Error = azure_core::Error;
    fn try_from(value: ModelWithRenamedFields) -> Result<Self> {
        RequestContent::try_from(to_xml(&value)?)
    }
}

impl TryFrom<Response<ModelWithRenamedFields>> for ModelWithRenamedFields {
    type Error = azure_core::Error;
    fn try_from(value: Response<ModelWithRenamedFields>) -> Result<Self> {
        let f = || value.into_body().xml::<ModelWithRenamedFields>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<ModelWithSimpleArrays> for RequestContent<ModelWithSimpleArrays> {
    type Error = azure_core::Error;
    fn try_from(value: ModelWithSimpleArrays) -> Result<Self> {
        RequestContent::try_from(to_xml(&value)?)
    }
}

impl TryFrom<Response<ModelWithSimpleArrays>> for ModelWithSimpleArrays {
    type Error = azure_core::Error;
    fn try_from(value: Response<ModelWithSimpleArrays>) -> Result<Self> {
        let f = || value.into_body().xml::<ModelWithSimpleArrays>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<ModelWithText> for RequestContent<ModelWithText> {
    type Error = azure_core::Error;
    fn try_from(value: ModelWithText) -> Result<Self> {
        RequestContent::try_from(to_xml(&value)?)
    }
}

impl TryFrom<Response<ModelWithText>> for ModelWithText {
    type Error = azure_core::Error;
    fn try_from(value: Response<ModelWithText>) -> Result<Self> {
        let f = || value.into_body().xml::<ModelWithText>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<ModelWithUnwrappedArray> for RequestContent<ModelWithUnwrappedArray> {
    type Error = azure_core::Error;
    fn try_from(value: ModelWithUnwrappedArray) -> Result<Self> {
        RequestContent::try_from(to_xml(&value)?)
    }
}

impl TryFrom<Response<ModelWithUnwrappedArray>> for ModelWithUnwrappedArray {
    type Error = azure_core::Error;
    fn try_from(value: Response<ModelWithUnwrappedArray>) -> Result<Self> {
        let f = || value.into_body().xml::<ModelWithUnwrappedArray>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<SimpleModel> for RequestContent<SimpleModel> {
    type Error = azure_core::Error;
    fn try_from(value: SimpleModel) -> Result<Self> {
        RequestContent::try_from(to_xml(&value)?)
    }
}

impl TryFrom<Response<SimpleModel>> for SimpleModel {
    type Error = azure_core::Error;
    fn try_from(value: Response<SimpleModel>) -> Result<Self> {
        let f = || value.into_body().xml::<SimpleModel>();
        let r = block_on(f())?;
        Ok(r)
    }
}
