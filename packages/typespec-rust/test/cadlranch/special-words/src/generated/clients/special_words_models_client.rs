// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{
    And, As, Assert, Async, Await, Break, Class, Constructor, Continue, Def, Del, Elif, Else,
    Except, Exec, Finally, For, From, Global, If, Import, In, Is, Lambda, Not, Or, Pass, Raise,
    Return, Try, While, With, Yield,
};
use azure_core::builders::ClientMethodOptionsBuilder;
use azure_core::{
    AsClientMethodOptions, ClientMethodOptions, Context, Method, Pipeline, Request, RequestContent,
    Response, Result, Url,
};

pub struct SpecialWordsModelsClient {
    pub(in crate::generated::clients) endpoint: Url,
    pub(in crate::generated::clients) pipeline: Pipeline,
}

impl SpecialWordsModelsClient {
    pub async fn with_and(
        &self,
        body: RequestContent<And>,
        options: Option<SpecialWordsModelsClientWithAndOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/and");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_as(
        &self,
        body: RequestContent<As>,
        options: Option<SpecialWordsModelsClientWithAsOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/as");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_assert(
        &self,
        body: RequestContent<Assert>,
        options: Option<SpecialWordsModelsClientWithAssertOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/assert");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_async(
        &self,
        body: RequestContent<Async>,
        options: Option<SpecialWordsModelsClientWithAsyncOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/async");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_await(
        &self,
        body: RequestContent<Await>,
        options: Option<SpecialWordsModelsClientWithAwaitOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/await");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_break(
        &self,
        body: RequestContent<Break>,
        options: Option<SpecialWordsModelsClientWithBreakOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/break");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_class(
        &self,
        body: RequestContent<Class>,
        options: Option<SpecialWordsModelsClientWithClassOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/class");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_constructor(
        &self,
        body: RequestContent<Constructor>,
        options: Option<SpecialWordsModelsClientWithConstructorOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/constructor");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_continue(
        &self,
        body: RequestContent<Continue>,
        options: Option<SpecialWordsModelsClientWithContinueOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/continue");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_def(
        &self,
        body: RequestContent<Def>,
        options: Option<SpecialWordsModelsClientWithDefOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/def");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_del(
        &self,
        body: RequestContent<Del>,
        options: Option<SpecialWordsModelsClientWithDelOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/del");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_elif(
        &self,
        body: RequestContent<Elif>,
        options: Option<SpecialWordsModelsClientWithElifOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/elif");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_else(
        &self,
        body: RequestContent<Else>,
        options: Option<SpecialWordsModelsClientWithElseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/else");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_except(
        &self,
        body: RequestContent<Except>,
        options: Option<SpecialWordsModelsClientWithExceptOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/except");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_exec(
        &self,
        body: RequestContent<Exec>,
        options: Option<SpecialWordsModelsClientWithExecOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/exec");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_finally(
        &self,
        body: RequestContent<Finally>,
        options: Option<SpecialWordsModelsClientWithFinallyOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/finally");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_for(
        &self,
        body: RequestContent<For>,
        options: Option<SpecialWordsModelsClientWithForOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/for");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_from(
        &self,
        body: RequestContent<From>,
        options: Option<SpecialWordsModelsClientWithFromOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/from");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_global(
        &self,
        body: RequestContent<Global>,
        options: Option<SpecialWordsModelsClientWithGlobalOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/global");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_if(
        &self,
        body: RequestContent<If>,
        options: Option<SpecialWordsModelsClientWithIfOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/if");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_import(
        &self,
        body: RequestContent<Import>,
        options: Option<SpecialWordsModelsClientWithImportOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/import");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_in(
        &self,
        body: RequestContent<In>,
        options: Option<SpecialWordsModelsClientWithInOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/in");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_is(
        &self,
        body: RequestContent<Is>,
        options: Option<SpecialWordsModelsClientWithIsOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/is");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_lambda(
        &self,
        body: RequestContent<Lambda>,
        options: Option<SpecialWordsModelsClientWithLambdaOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/lambda");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_not(
        &self,
        body: RequestContent<Not>,
        options: Option<SpecialWordsModelsClientWithNotOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/not");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_or(
        &self,
        body: RequestContent<Or>,
        options: Option<SpecialWordsModelsClientWithOrOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/or");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_pass(
        &self,
        body: RequestContent<Pass>,
        options: Option<SpecialWordsModelsClientWithPassOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/pass");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_raise(
        &self,
        body: RequestContent<Raise>,
        options: Option<SpecialWordsModelsClientWithRaiseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/raise");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_return(
        &self,
        body: RequestContent<Return>,
        options: Option<SpecialWordsModelsClientWithReturnOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/return");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_try(
        &self,
        body: RequestContent<Try>,
        options: Option<SpecialWordsModelsClientWithTryOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/try");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_while(
        &self,
        body: RequestContent<While>,
        options: Option<SpecialWordsModelsClientWithWhileOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/while");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_with(
        &self,
        body: RequestContent<With>,
        options: Option<SpecialWordsModelsClientWithOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/with");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with_yield(
        &self,
        body: RequestContent<Yield>,
        options: Option<SpecialWordsModelsClientWithYieldOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/models/yield");
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithAndOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithAndOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithAndOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithAndOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithAsOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithAsOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithAsOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithAsOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithAssertOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithAssertOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithAssertOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithAssertOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithAsyncOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithAsyncOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithAsyncOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithAsyncOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithAwaitOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithAwaitOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithAwaitOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithAwaitOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithBreakOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithBreakOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithBreakOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithBreakOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithClassOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithClassOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithClassOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithClassOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithConstructorOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithConstructorOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithConstructorOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithConstructorOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithContinueOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithContinueOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithContinueOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithContinueOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithDefOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithDefOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithDefOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithDefOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithDelOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithDelOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithDelOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithDelOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithElifOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithElifOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithElifOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithElifOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithElseOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithElseOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithElseOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithElseOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithExceptOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithExceptOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithExceptOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithExceptOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithExecOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithExecOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithExecOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithExecOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithFinallyOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithFinallyOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithFinallyOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithFinallyOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithForOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithForOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithForOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithForOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithFromOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithFromOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithFromOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithFromOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithGlobalOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithGlobalOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithGlobalOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithGlobalOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithIfOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithIfOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithIfOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithIfOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithImportOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithImportOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithImportOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithImportOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithInOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithInOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithInOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithInOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithIsOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithIsOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithIsOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithIsOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithLambdaOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithLambdaOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithLambdaOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithLambdaOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithNotOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithNotOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithNotOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithNotOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithOrOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithOrOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithOrOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithOrOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithPassOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithPassOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithPassOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithPassOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithRaiseOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithRaiseOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithRaiseOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithRaiseOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithReturnOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithReturnOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithReturnOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithReturnOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithTryOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithTryOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithTryOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithTryOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithWhileOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithWhileOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithWhileOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithWhileOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsModelsClientWithYieldOptions<'a> {
    method_options: ClientMethodOptions<'a>,
}

impl<'a> SpecialWordsModelsClientWithYieldOptions<'a> {
    pub fn builder() -> builders::SpecialWordsModelsClientWithYieldOptionsBuilder<'a> {
        builders::SpecialWordsModelsClientWithYieldOptionsBuilder::new()
    }
}

pub mod builders {
    use super::*;

    pub struct SpecialWordsModelsClientWithAndOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithAndOptions<'a>,
    }

    impl SpecialWordsModelsClientWithAndOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithAndOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithAndOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithAndOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithAsOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithAsOptions<'a>,
    }

    impl SpecialWordsModelsClientWithAsOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithAsOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithAsOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithAsOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithAssertOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithAssertOptions<'a>,
    }

    impl SpecialWordsModelsClientWithAssertOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithAssertOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithAssertOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithAssertOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithAsyncOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithAsyncOptions<'a>,
    }

    impl SpecialWordsModelsClientWithAsyncOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithAsyncOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithAsyncOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithAsyncOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithAwaitOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithAwaitOptions<'a>,
    }

    impl SpecialWordsModelsClientWithAwaitOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithAwaitOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithAwaitOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithAwaitOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithBreakOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithBreakOptions<'a>,
    }

    impl SpecialWordsModelsClientWithBreakOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithBreakOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithBreakOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithBreakOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithClassOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithClassOptions<'a>,
    }

    impl SpecialWordsModelsClientWithClassOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithClassOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithClassOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithClassOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithConstructorOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithConstructorOptions<'a>,
    }

    impl SpecialWordsModelsClientWithConstructorOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithConstructorOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithConstructorOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a>
        for SpecialWordsModelsClientWithConstructorOptionsBuilder<'a>
    {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithContinueOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithContinueOptions<'a>,
    }

    impl SpecialWordsModelsClientWithContinueOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithContinueOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithContinueOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithContinueOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithDefOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithDefOptions<'a>,
    }

    impl SpecialWordsModelsClientWithDefOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithDefOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithDefOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithDefOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithDelOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithDelOptions<'a>,
    }

    impl SpecialWordsModelsClientWithDelOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithDelOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithDelOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithDelOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithElifOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithElifOptions<'a>,
    }

    impl SpecialWordsModelsClientWithElifOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithElifOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithElifOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithElifOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithElseOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithElseOptions<'a>,
    }

    impl SpecialWordsModelsClientWithElseOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithElseOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithElseOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithElseOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithExceptOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithExceptOptions<'a>,
    }

    impl SpecialWordsModelsClientWithExceptOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithExceptOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithExceptOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithExceptOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithExecOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithExecOptions<'a>,
    }

    impl SpecialWordsModelsClientWithExecOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithExecOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithExecOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithExecOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithFinallyOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithFinallyOptions<'a>,
    }

    impl SpecialWordsModelsClientWithFinallyOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithFinallyOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithFinallyOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithFinallyOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithForOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithForOptions<'a>,
    }

    impl SpecialWordsModelsClientWithForOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithForOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithForOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithForOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithFromOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithFromOptions<'a>,
    }

    impl SpecialWordsModelsClientWithFromOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithFromOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithFromOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithFromOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithGlobalOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithGlobalOptions<'a>,
    }

    impl SpecialWordsModelsClientWithGlobalOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithGlobalOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithGlobalOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithGlobalOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithIfOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithIfOptions<'a>,
    }

    impl SpecialWordsModelsClientWithIfOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithIfOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithIfOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithIfOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithImportOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithImportOptions<'a>,
    }

    impl SpecialWordsModelsClientWithImportOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithImportOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithImportOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithImportOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithInOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithInOptions<'a>,
    }

    impl SpecialWordsModelsClientWithInOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithInOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithInOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithInOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithIsOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithIsOptions<'a>,
    }

    impl SpecialWordsModelsClientWithIsOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithIsOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithIsOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithIsOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithLambdaOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithLambdaOptions<'a>,
    }

    impl SpecialWordsModelsClientWithLambdaOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithLambdaOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithLambdaOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithLambdaOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithNotOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithNotOptions<'a>,
    }

    impl SpecialWordsModelsClientWithNotOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithNotOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithNotOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithNotOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithOrOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithOrOptions<'a>,
    }

    impl SpecialWordsModelsClientWithOrOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithOrOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithOrOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithOrOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithPassOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithPassOptions<'a>,
    }

    impl SpecialWordsModelsClientWithPassOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithPassOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithPassOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithPassOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithRaiseOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithRaiseOptions<'a>,
    }

    impl SpecialWordsModelsClientWithRaiseOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithRaiseOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithRaiseOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithRaiseOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithReturnOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithReturnOptions<'a>,
    }

    impl SpecialWordsModelsClientWithReturnOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithReturnOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithReturnOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithReturnOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithTryOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithTryOptions<'a>,
    }

    impl SpecialWordsModelsClientWithTryOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithTryOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithTryOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithTryOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithWhileOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithWhileOptions<'a>,
    }

    impl SpecialWordsModelsClientWithWhileOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithWhileOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithWhileOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithWhileOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithOptions<'a>,
    }

    impl SpecialWordsModelsClientWithOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct SpecialWordsModelsClientWithYieldOptionsBuilder<'a> {
        options: SpecialWordsModelsClientWithYieldOptions<'a>,
    }

    impl SpecialWordsModelsClientWithYieldOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: SpecialWordsModelsClientWithYieldOptions::default(),
            }
        }

        pub fn build(&self) -> SpecialWordsModelsClientWithYieldOptions {
            self.options.clone()
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for SpecialWordsModelsClientWithYieldOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }
}
