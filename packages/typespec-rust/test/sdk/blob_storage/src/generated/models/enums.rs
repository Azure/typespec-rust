// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::{
    convert::{AsRef, From, Infallible},
    fmt::{Display, Formatter},
    str::FromStr,
};

/// The access tiers.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum AccessTier {
    /// The archive access tier.
    Archive,

    /// The Cold access tier.
    Cold,

    /// The cool access tier.
    Cool,

    /// The hot access tier.
    Hot,

    /// The hot P10 tier.
    P10,

    /// The hot P15 tier.
    P15,

    /// The hot P20 tier.
    P20,

    /// The hot P30 tier.
    P30,

    /// The hot P4 tier.
    P4,

    /// The hot P40 tier.
    P40,

    /// The hot P50 tier.
    P50,

    /// The hot P6 tier.
    P6,

    /// The hot P60 tier.
    P60,

    /// The hot P70 tier.
    P70,

    /// The hot P80 tier.
    P80,

    /// The Premium access tier.
    Premium,

    /// Any other value not defined in `AccessTier`.
    UnknownValue(String),
}

impl<'a> From<&'a AccessTier> for &'a str {
    fn from(e: &'a AccessTier) -> Self {
        match e {
            AccessTier::Archive => "Archive",
            AccessTier::Cold => "Cold",
            AccessTier::Cool => "Cool",
            AccessTier::Hot => "Hot",
            AccessTier::P10 => "P10",
            AccessTier::P15 => "P15",
            AccessTier::P20 => "P20",
            AccessTier::P30 => "P30",
            AccessTier::P4 => "P4",
            AccessTier::P40 => "P40",
            AccessTier::P50 => "P50",
            AccessTier::P6 => "P6",
            AccessTier::P60 => "P60",
            AccessTier::P70 => "P70",
            AccessTier::P80 => "P80",
            AccessTier::Premium => "Premium",
            AccessTier::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for AccessTier {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Archive" => AccessTier::Archive,
            "Cold" => AccessTier::Cold,
            "Cool" => AccessTier::Cool,
            "Hot" => AccessTier::Hot,
            "P10" => AccessTier::P10,
            "P15" => AccessTier::P15,
            "P20" => AccessTier::P20,
            "P30" => AccessTier::P30,
            "P4" => AccessTier::P4,
            "P40" => AccessTier::P40,
            "P50" => AccessTier::P50,
            "P6" => AccessTier::P6,
            "P60" => AccessTier::P60,
            "P70" => AccessTier::P70,
            "P80" => AccessTier::P80,
            "Premium" => AccessTier::Premium,
            _ => AccessTier::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for AccessTier {
    fn as_ref(&self) -> &str {
        match self {
            AccessTier::Archive => "Archive",
            AccessTier::Cold => "Cold",
            AccessTier::Cool => "Cool",
            AccessTier::Hot => "Hot",
            AccessTier::P10 => "P10",
            AccessTier::P15 => "P15",
            AccessTier::P20 => "P20",
            AccessTier::P30 => "P30",
            AccessTier::P4 => "P4",
            AccessTier::P40 => "P40",
            AccessTier::P50 => "P50",
            AccessTier::P6 => "P6",
            AccessTier::P60 => "P60",
            AccessTier::P70 => "P70",
            AccessTier::P80 => "P80",
            AccessTier::Premium => "Premium",
            AccessTier::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for AccessTier {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AccessTier::Archive => f.write_str("Archive"),
            AccessTier::Cold => f.write_str("Cold"),
            AccessTier::Cool => f.write_str("Cool"),
            AccessTier::Hot => f.write_str("Hot"),
            AccessTier::P10 => f.write_str("P10"),
            AccessTier::P15 => f.write_str("P15"),
            AccessTier::P20 => f.write_str("P20"),
            AccessTier::P30 => f.write_str("P30"),
            AccessTier::P4 => f.write_str("P4"),
            AccessTier::P40 => f.write_str("P40"),
            AccessTier::P50 => f.write_str("P50"),
            AccessTier::P6 => f.write_str("P6"),
            AccessTier::P60 => f.write_str("P60"),
            AccessTier::P70 => f.write_str("P70"),
            AccessTier::P80 => f.write_str("P80"),
            AccessTier::Premium => f.write_str("Premium"),
            AccessTier::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for AccessTier {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for AccessTier {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The account kind.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum AccountKind {
    /// The storage account is a blob storage account.
    BlobStorage,

    /// The storage account is a block blob storage account.
    BlockBlobStorage,

    /// The storage account is a file storage account.
    FileStorage,

    /// The storage account is a general-purpose account.
    Storage,

    /// The storage account is a storage V2 account.
    StorageV2,

    /// Any other value not defined in `AccountKind`.
    UnknownValue(String),
}

impl<'a> From<&'a AccountKind> for &'a str {
    fn from(e: &'a AccountKind) -> Self {
        match e {
            AccountKind::BlobStorage => "BlobStorage",
            AccountKind::BlockBlobStorage => "BlockBlobStorage",
            AccountKind::FileStorage => "FileStorage",
            AccountKind::Storage => "Storage",
            AccountKind::StorageV2 => "StorageV2",
            AccountKind::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for AccountKind {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "BlobStorage" => AccountKind::BlobStorage,
            "BlockBlobStorage" => AccountKind::BlockBlobStorage,
            "FileStorage" => AccountKind::FileStorage,
            "Storage" => AccountKind::Storage,
            "StorageV2" => AccountKind::StorageV2,
            _ => AccountKind::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for AccountKind {
    fn as_ref(&self) -> &str {
        match self {
            AccountKind::BlobStorage => "BlobStorage",
            AccountKind::BlockBlobStorage => "BlockBlobStorage",
            AccountKind::FileStorage => "FileStorage",
            AccountKind::Storage => "Storage",
            AccountKind::StorageV2 => "StorageV2",
            AccountKind::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for AccountKind {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AccountKind::BlobStorage => f.write_str("BlobStorage"),
            AccountKind::BlockBlobStorage => f.write_str("BlockBlobStorage"),
            AccountKind::FileStorage => f.write_str("FileStorage"),
            AccountKind::Storage => f.write_str("Storage"),
            AccountKind::StorageV2 => f.write_str("StorageV2"),
            AccountKind::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for AccountKind {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for AccountKind {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The archive status.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum ArchiveStatus {
    /// The archive status is rehydrating pending to archive.
    RehydratePendingToCold,

    /// The archive status is rehydrating pending to cool.
    RehydratePendingToCool,

    /// The archive status is rehydrating pending to hot.
    RehydratePendingToHot,

    /// Any other value not defined in `ArchiveStatus`.
    UnknownValue(String),
}

impl<'a> From<&'a ArchiveStatus> for &'a str {
    fn from(e: &'a ArchiveStatus) -> Self {
        match e {
            ArchiveStatus::RehydratePendingToCold => "rehydrate-pending-to-cold",
            ArchiveStatus::RehydratePendingToCool => "rehydrate-pending-to-cool",
            ArchiveStatus::RehydratePendingToHot => "rehydrate-pending-to-hot",
            ArchiveStatus::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ArchiveStatus {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "rehydrate-pending-to-cold" => ArchiveStatus::RehydratePendingToCold,
            "rehydrate-pending-to-cool" => ArchiveStatus::RehydratePendingToCool,
            "rehydrate-pending-to-hot" => ArchiveStatus::RehydratePendingToHot,
            _ => ArchiveStatus::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ArchiveStatus {
    fn as_ref(&self) -> &str {
        match self {
            ArchiveStatus::RehydratePendingToCold => "rehydrate-pending-to-cold",
            ArchiveStatus::RehydratePendingToCool => "rehydrate-pending-to-cool",
            ArchiveStatus::RehydratePendingToHot => "rehydrate-pending-to-hot",
            ArchiveStatus::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ArchiveStatus {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ArchiveStatus::RehydratePendingToCold => f.write_str("rehydrate-pending-to-cold"),
            ArchiveStatus::RehydratePendingToCool => f.write_str("rehydrate-pending-to-cool"),
            ArchiveStatus::RehydratePendingToHot => f.write_str("rehydrate-pending-to-hot"),
            ArchiveStatus::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for ArchiveStatus {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for ArchiveStatus {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The type of blob deletions.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum BlobDeleteType {
    /// Permanently delete the blob.
    Permanent,

    /// Any other value not defined in `BlobDeleteType`.
    UnknownValue(String),
}

impl<'a> From<&'a BlobDeleteType> for &'a str {
    fn from(e: &'a BlobDeleteType) -> Self {
        match e {
            BlobDeleteType::Permanent => "Permanent",
            BlobDeleteType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for BlobDeleteType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Permanent" => BlobDeleteType::Permanent,
            _ => BlobDeleteType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for BlobDeleteType {
    fn as_ref(&self) -> &str {
        match self {
            BlobDeleteType::Permanent => "Permanent",
            BlobDeleteType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for BlobDeleteType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlobDeleteType::Permanent => f.write_str("Permanent"),
            BlobDeleteType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for BlobDeleteType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for BlobDeleteType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The blob expiration options.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum BlobExpiryOptions {
    /// Absolute time.
    Absolute,

    /// Never expire.
    NeverExpire,

    /// Relative to creation time.
    RelativeToCreation,

    /// Relative to now.
    RelativeToNow,

    /// Any other value not defined in `BlobExpiryOptions`.
    UnknownValue(String),
}

impl<'a> From<&'a BlobExpiryOptions> for &'a str {
    fn from(e: &'a BlobExpiryOptions) -> Self {
        match e {
            BlobExpiryOptions::Absolute => "Absolute",
            BlobExpiryOptions::NeverExpire => "NeverExpire",
            BlobExpiryOptions::RelativeToCreation => "RelativeToCreation",
            BlobExpiryOptions::RelativeToNow => "RelativeToNow",
            BlobExpiryOptions::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for BlobExpiryOptions {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Absolute" => BlobExpiryOptions::Absolute,
            "NeverExpire" => BlobExpiryOptions::NeverExpire,
            "RelativeToCreation" => BlobExpiryOptions::RelativeToCreation,
            "RelativeToNow" => BlobExpiryOptions::RelativeToNow,
            _ => BlobExpiryOptions::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for BlobExpiryOptions {
    fn as_ref(&self) -> &str {
        match self {
            BlobExpiryOptions::Absolute => "Absolute",
            BlobExpiryOptions::NeverExpire => "NeverExpire",
            BlobExpiryOptions::RelativeToCreation => "RelativeToCreation",
            BlobExpiryOptions::RelativeToNow => "RelativeToNow",
            BlobExpiryOptions::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for BlobExpiryOptions {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlobExpiryOptions::Absolute => f.write_str("Absolute"),
            BlobExpiryOptions::NeverExpire => f.write_str("NeverExpire"),
            BlobExpiryOptions::RelativeToCreation => f.write_str("RelativeToCreation"),
            BlobExpiryOptions::RelativeToNow => f.write_str("RelativeToNow"),
            BlobExpiryOptions::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for BlobExpiryOptions {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for BlobExpiryOptions {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The immutability policy mode.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum BlobImmutabilityPolicyMode {
    /// The immutability policy is locked.
    Locked,

    /// The immutability policy is mutable.
    Mutable,

    /// The immutability policy is unlocked.
    Unlocked,

    /// Any other value not defined in `BlobImmutabilityPolicyMode`.
    UnknownValue(String),
}

impl<'a> From<&'a BlobImmutabilityPolicyMode> for &'a str {
    fn from(e: &'a BlobImmutabilityPolicyMode) -> Self {
        match e {
            BlobImmutabilityPolicyMode::Locked => "Locked",
            BlobImmutabilityPolicyMode::Mutable => "Mutable",
            BlobImmutabilityPolicyMode::Unlocked => "Unlocked",
            BlobImmutabilityPolicyMode::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for BlobImmutabilityPolicyMode {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Locked" => BlobImmutabilityPolicyMode::Locked,
            "Mutable" => BlobImmutabilityPolicyMode::Mutable,
            "Unlocked" => BlobImmutabilityPolicyMode::Unlocked,
            _ => BlobImmutabilityPolicyMode::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for BlobImmutabilityPolicyMode {
    fn as_ref(&self) -> &str {
        match self {
            BlobImmutabilityPolicyMode::Locked => "Locked",
            BlobImmutabilityPolicyMode::Mutable => "Mutable",
            BlobImmutabilityPolicyMode::Unlocked => "Unlocked",
            BlobImmutabilityPolicyMode::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for BlobImmutabilityPolicyMode {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlobImmutabilityPolicyMode::Locked => f.write_str("Locked"),
            BlobImmutabilityPolicyMode::Mutable => f.write_str("Mutable"),
            BlobImmutabilityPolicyMode::Unlocked => f.write_str("Unlocked"),
            BlobImmutabilityPolicyMode::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for BlobImmutabilityPolicyMode {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for BlobImmutabilityPolicyMode {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The blob type.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum BlobType {
    /// The blob is an append blob.
    AppendBlob,

    /// The blob is a block blob.
    BlockBlob,

    /// The blob is a page blob.
    PageBlob,

    /// Any other value not defined in `BlobType`.
    UnknownValue(String),
}

impl<'a> From<&'a BlobType> for &'a str {
    fn from(e: &'a BlobType) -> Self {
        match e {
            BlobType::AppendBlob => "AppendBlob",
            BlobType::BlockBlob => "BlockBlob",
            BlobType::PageBlob => "PageBlob",
            BlobType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for BlobType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "AppendBlob" => BlobType::AppendBlob,
            "BlockBlob" => BlobType::BlockBlob,
            "PageBlob" => BlobType::PageBlob,
            _ => BlobType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for BlobType {
    fn as_ref(&self) -> &str {
        match self {
            BlobType::AppendBlob => "AppendBlob",
            BlobType::BlockBlob => "BlockBlob",
            BlobType::PageBlob => "PageBlob",
            BlobType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for BlobType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlobType::AppendBlob => f.write_str("AppendBlob"),
            BlobType::BlockBlob => f.write_str("BlockBlob"),
            BlobType::PageBlob => f.write_str("PageBlob"),
            BlobType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for BlobType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for BlobType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The block list types.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum BlockListType {
    /// Both lists together.
    All,

    /// The list of committed blocks.
    Committed,

    /// The list of uncommitted blocks.
    Uncommitted,

    /// Any other value not defined in `BlockListType`.
    UnknownValue(String),
}

impl<'a> From<&'a BlockListType> for &'a str {
    fn from(e: &'a BlockListType) -> Self {
        match e {
            BlockListType::All => "all",
            BlockListType::Committed => "committed",
            BlockListType::Uncommitted => "uncommitted",
            BlockListType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for BlockListType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "all" => BlockListType::All,
            "committed" => BlockListType::Committed,
            "uncommitted" => BlockListType::Uncommitted,
            _ => BlockListType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for BlockListType {
    fn as_ref(&self) -> &str {
        match self {
            BlockListType::All => "all",
            BlockListType::Committed => "committed",
            BlockListType::Uncommitted => "uncommitted",
            BlockListType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for BlockListType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlockListType::All => f.write_str("all"),
            BlockListType::Committed => f.write_str("committed"),
            BlockListType::Uncommitted => f.write_str("uncommitted"),
            BlockListType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for BlockListType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for BlockListType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The copy status.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum CopyStatus {
    /// The copy operation is aborted.
    Aborted,

    /// The copy operation failed.
    Failed,

    /// The copy operation is pending.
    Pending,

    /// The copy operation succeeded.
    Success,

    /// Any other value not defined in `CopyStatus`.
    UnknownValue(String),
}

impl<'a> From<&'a CopyStatus> for &'a str {
    fn from(e: &'a CopyStatus) -> Self {
        match e {
            CopyStatus::Aborted => "aborted",
            CopyStatus::Failed => "failed",
            CopyStatus::Pending => "pending",
            CopyStatus::Success => "success",
            CopyStatus::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for CopyStatus {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "aborted" => CopyStatus::Aborted,
            "failed" => CopyStatus::Failed,
            "pending" => CopyStatus::Pending,
            "success" => CopyStatus::Success,
            _ => CopyStatus::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for CopyStatus {
    fn as_ref(&self) -> &str {
        match self {
            CopyStatus::Aborted => "aborted",
            CopyStatus::Failed => "failed",
            CopyStatus::Pending => "pending",
            CopyStatus::Success => "success",
            CopyStatus::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for CopyStatus {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            CopyStatus::Aborted => f.write_str("aborted"),
            CopyStatus::Failed => f.write_str("failed"),
            CopyStatus::Pending => f.write_str("pending"),
            CopyStatus::Success => f.write_str("success"),
            CopyStatus::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for CopyStatus {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for CopyStatus {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The delete snapshots option type.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum DeleteSnapshotsOptionType {
    /// The delete snapshots include option is include.
    Include,

    /// The delete snapshots include option is only.
    Only,

    /// Any other value not defined in `DeleteSnapshotsOptionType`.
    UnknownValue(String),
}

impl<'a> From<&'a DeleteSnapshotsOptionType> for &'a str {
    fn from(e: &'a DeleteSnapshotsOptionType) -> Self {
        match e {
            DeleteSnapshotsOptionType::Include => "include",
            DeleteSnapshotsOptionType::Only => "only",
            DeleteSnapshotsOptionType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for DeleteSnapshotsOptionType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "include" => DeleteSnapshotsOptionType::Include,
            "only" => DeleteSnapshotsOptionType::Only,
            _ => DeleteSnapshotsOptionType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for DeleteSnapshotsOptionType {
    fn as_ref(&self) -> &str {
        match self {
            DeleteSnapshotsOptionType::Include => "include",
            DeleteSnapshotsOptionType::Only => "only",
            DeleteSnapshotsOptionType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for DeleteSnapshotsOptionType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            DeleteSnapshotsOptionType::Include => f.write_str("include"),
            DeleteSnapshotsOptionType::Only => f.write_str("only"),
            DeleteSnapshotsOptionType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for DeleteSnapshotsOptionType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for DeleteSnapshotsOptionType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The algorithm used to produce the encryption key hash. Currently, the only accepted value is \"AES256\". Must be provided
/// if the x-ms-encryption-key header is provided.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum EncryptionAlgorithmType {
    /// The AES256 encryption algorithm.
    Aes256,

    /// Any other value not defined in `EncryptionAlgorithmType`.
    UnknownValue(String),
}

impl<'a> From<&'a EncryptionAlgorithmType> for &'a str {
    fn from(e: &'a EncryptionAlgorithmType) -> Self {
        match e {
            EncryptionAlgorithmType::Aes256 => "AES256",
            EncryptionAlgorithmType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for EncryptionAlgorithmType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "AES256" => EncryptionAlgorithmType::Aes256,
            _ => EncryptionAlgorithmType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for EncryptionAlgorithmType {
    fn as_ref(&self) -> &str {
        match self {
            EncryptionAlgorithmType::Aes256 => "AES256",
            EncryptionAlgorithmType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for EncryptionAlgorithmType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            EncryptionAlgorithmType::Aes256 => f.write_str("AES256"),
            EncryptionAlgorithmType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for EncryptionAlgorithmType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for EncryptionAlgorithmType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The filter blobs includes.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum FilterBlobsIncludeItem {
    /// The filter includes no versions.
    None,

    /// The filter includes n versions.
    Versions,

    /// Any other value not defined in `FilterBlobsIncludeItem`.
    UnknownValue(String),
}

impl<'a> From<&'a FilterBlobsIncludeItem> for &'a str {
    fn from(e: &'a FilterBlobsIncludeItem) -> Self {
        match e {
            FilterBlobsIncludeItem::None => "none",
            FilterBlobsIncludeItem::Versions => "versions",
            FilterBlobsIncludeItem::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for FilterBlobsIncludeItem {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "none" => FilterBlobsIncludeItem::None,
            "versions" => FilterBlobsIncludeItem::Versions,
            _ => FilterBlobsIncludeItem::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for FilterBlobsIncludeItem {
    fn as_ref(&self) -> &str {
        match self {
            FilterBlobsIncludeItem::None => "none",
            FilterBlobsIncludeItem::Versions => "versions",
            FilterBlobsIncludeItem::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for FilterBlobsIncludeItem {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            FilterBlobsIncludeItem::None => f.write_str("none"),
            FilterBlobsIncludeItem::Versions => f.write_str("versions"),
            FilterBlobsIncludeItem::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for FilterBlobsIncludeItem {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for FilterBlobsIncludeItem {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The geo replication status.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum GeoReplicationStatusType {
    /// The geo replication is bootstrap.
    Bootstrap,

    /// The geo replication is live.
    Live,

    /// The geo replication is unavailable.
    Unavailable,

    /// Any other value not defined in `GeoReplicationStatusType`.
    UnknownValue(String),
}

impl<'a> From<&'a GeoReplicationStatusType> for &'a str {
    fn from(e: &'a GeoReplicationStatusType) -> Self {
        match e {
            GeoReplicationStatusType::Bootstrap => "bootstrap",
            GeoReplicationStatusType::Live => "live",
            GeoReplicationStatusType::Unavailable => "unavailable",
            GeoReplicationStatusType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for GeoReplicationStatusType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "bootstrap" => GeoReplicationStatusType::Bootstrap,
            "live" => GeoReplicationStatusType::Live,
            "unavailable" => GeoReplicationStatusType::Unavailable,
            _ => GeoReplicationStatusType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for GeoReplicationStatusType {
    fn as_ref(&self) -> &str {
        match self {
            GeoReplicationStatusType::Bootstrap => "bootstrap",
            GeoReplicationStatusType::Live => "live",
            GeoReplicationStatusType::Unavailable => "unavailable",
            GeoReplicationStatusType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for GeoReplicationStatusType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            GeoReplicationStatusType::Bootstrap => f.write_str("bootstrap"),
            GeoReplicationStatusType::Live => f.write_str("live"),
            GeoReplicationStatusType::Unavailable => f.write_str("unavailable"),
            GeoReplicationStatusType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for GeoReplicationStatusType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for GeoReplicationStatusType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The lease duration.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum LeaseDuration {
    /// The lease is of fixed duration.
    Fixed,

    /// The lease is of infinite duration.
    Infinite,

    /// Any other value not defined in `LeaseDuration`.
    UnknownValue(String),
}

impl<'a> From<&'a LeaseDuration> for &'a str {
    fn from(e: &'a LeaseDuration) -> Self {
        match e {
            LeaseDuration::Fixed => "fixed",
            LeaseDuration::Infinite => "infinite",
            LeaseDuration::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for LeaseDuration {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "fixed" => LeaseDuration::Fixed,
            "infinite" => LeaseDuration::Infinite,
            _ => LeaseDuration::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for LeaseDuration {
    fn as_ref(&self) -> &str {
        match self {
            LeaseDuration::Fixed => "fixed",
            LeaseDuration::Infinite => "infinite",
            LeaseDuration::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for LeaseDuration {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            LeaseDuration::Fixed => f.write_str("fixed"),
            LeaseDuration::Infinite => f.write_str("infinite"),
            LeaseDuration::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for LeaseDuration {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for LeaseDuration {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The lease state.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum LeaseState {
    /// The lease is available.
    Available,

    /// The lease is breaking.
    Breaking,

    /// The lease is broken.
    Broken,

    /// The lease is expired.
    Expired,

    /// The lease is currently leased.
    Leased,

    /// Any other value not defined in `LeaseState`.
    UnknownValue(String),
}

impl<'a> From<&'a LeaseState> for &'a str {
    fn from(e: &'a LeaseState) -> Self {
        match e {
            LeaseState::Available => "available",
            LeaseState::Breaking => "breaking",
            LeaseState::Broken => "broken",
            LeaseState::Expired => "expired",
            LeaseState::Leased => "leased",
            LeaseState::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for LeaseState {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "available" => LeaseState::Available,
            "breaking" => LeaseState::Breaking,
            "broken" => LeaseState::Broken,
            "expired" => LeaseState::Expired,
            "leased" => LeaseState::Leased,
            _ => LeaseState::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for LeaseState {
    fn as_ref(&self) -> &str {
        match self {
            LeaseState::Available => "available",
            LeaseState::Breaking => "breaking",
            LeaseState::Broken => "broken",
            LeaseState::Expired => "expired",
            LeaseState::Leased => "leased",
            LeaseState::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for LeaseState {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            LeaseState::Available => f.write_str("available"),
            LeaseState::Breaking => f.write_str("breaking"),
            LeaseState::Broken => f.write_str("broken"),
            LeaseState::Expired => f.write_str("expired"),
            LeaseState::Leased => f.write_str("leased"),
            LeaseState::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for LeaseState {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for LeaseState {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The lease status.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum LeaseStatus {
    /// The lease is locked.
    Locked,

    /// The lease is unlocked.
    Unlocked,

    /// Any other value not defined in `LeaseStatus`.
    UnknownValue(String),
}

impl<'a> From<&'a LeaseStatus> for &'a str {
    fn from(e: &'a LeaseStatus) -> Self {
        match e {
            LeaseStatus::Locked => "locked",
            LeaseStatus::Unlocked => "unlocked",
            LeaseStatus::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for LeaseStatus {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "locked" => LeaseStatus::Locked,
            "unlocked" => LeaseStatus::Unlocked,
            _ => LeaseStatus::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for LeaseStatus {
    fn as_ref(&self) -> &str {
        match self {
            LeaseStatus::Locked => "locked",
            LeaseStatus::Unlocked => "unlocked",
            LeaseStatus::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for LeaseStatus {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            LeaseStatus::Locked => f.write_str("locked"),
            LeaseStatus::Unlocked => f.write_str("unlocked"),
            LeaseStatus::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for LeaseStatus {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for LeaseStatus {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The list blob includes parameter values.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum ListBlobsIncludeItem {
    /// The include copies.
    Copy,

    /// The include deleted blobs.
    Deleted,

    /// The include deleted with versions.
    DeletedWithVersions,

    /// The include immutable policy.
    ImmutabilityPolicy,

    /// The include legal hold.
    LegalHold,

    /// The include metadata.
    Metadata,

    /// The include snapshots.
    Snapshots,

    /// The include tags.
    Tags,

    /// The include uncommitted blobs.
    UncommittedBlobs,

    /// The include versions.
    Versions,

    /// Any other value not defined in `ListBlobsIncludeItem`.
    UnknownValue(String),
}

impl<'a> From<&'a ListBlobsIncludeItem> for &'a str {
    fn from(e: &'a ListBlobsIncludeItem) -> Self {
        match e {
            ListBlobsIncludeItem::Copy => "copy",
            ListBlobsIncludeItem::Deleted => "deleted",
            ListBlobsIncludeItem::DeletedWithVersions => "deletedwithversions",
            ListBlobsIncludeItem::ImmutabilityPolicy => "immutabilitypolicy",
            ListBlobsIncludeItem::LegalHold => "legalhold",
            ListBlobsIncludeItem::Metadata => "metadata",
            ListBlobsIncludeItem::Snapshots => "snapshots",
            ListBlobsIncludeItem::Tags => "tags",
            ListBlobsIncludeItem::UncommittedBlobs => "uncommittedblobs",
            ListBlobsIncludeItem::Versions => "versions",
            ListBlobsIncludeItem::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ListBlobsIncludeItem {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "copy" => ListBlobsIncludeItem::Copy,
            "deleted" => ListBlobsIncludeItem::Deleted,
            "deletedwithversions" => ListBlobsIncludeItem::DeletedWithVersions,
            "immutabilitypolicy" => ListBlobsIncludeItem::ImmutabilityPolicy,
            "legalhold" => ListBlobsIncludeItem::LegalHold,
            "metadata" => ListBlobsIncludeItem::Metadata,
            "snapshots" => ListBlobsIncludeItem::Snapshots,
            "tags" => ListBlobsIncludeItem::Tags,
            "uncommittedblobs" => ListBlobsIncludeItem::UncommittedBlobs,
            "versions" => ListBlobsIncludeItem::Versions,
            _ => ListBlobsIncludeItem::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ListBlobsIncludeItem {
    fn as_ref(&self) -> &str {
        match self {
            ListBlobsIncludeItem::Copy => "copy",
            ListBlobsIncludeItem::Deleted => "deleted",
            ListBlobsIncludeItem::DeletedWithVersions => "deletedwithversions",
            ListBlobsIncludeItem::ImmutabilityPolicy => "immutabilitypolicy",
            ListBlobsIncludeItem::LegalHold => "legalhold",
            ListBlobsIncludeItem::Metadata => "metadata",
            ListBlobsIncludeItem::Snapshots => "snapshots",
            ListBlobsIncludeItem::Tags => "tags",
            ListBlobsIncludeItem::UncommittedBlobs => "uncommittedblobs",
            ListBlobsIncludeItem::Versions => "versions",
            ListBlobsIncludeItem::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ListBlobsIncludeItem {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ListBlobsIncludeItem::Copy => f.write_str("copy"),
            ListBlobsIncludeItem::Deleted => f.write_str("deleted"),
            ListBlobsIncludeItem::DeletedWithVersions => f.write_str("deletedwithversions"),
            ListBlobsIncludeItem::ImmutabilityPolicy => f.write_str("immutabilitypolicy"),
            ListBlobsIncludeItem::LegalHold => f.write_str("legalhold"),
            ListBlobsIncludeItem::Metadata => f.write_str("metadata"),
            ListBlobsIncludeItem::Snapshots => f.write_str("snapshots"),
            ListBlobsIncludeItem::Tags => f.write_str("tags"),
            ListBlobsIncludeItem::UncommittedBlobs => f.write_str("uncommittedblobs"),
            ListBlobsIncludeItem::Versions => f.write_str("versions"),
            ListBlobsIncludeItem::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for ListBlobsIncludeItem {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for ListBlobsIncludeItem {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// Include this parameter to specify that the container's metadata be returned as part of the response body.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum ListContainersIncludeType {
    /// Include deleted
    Deleted,

    /// Include metadata
    Metadata,

    /// Include system
    System,

    /// Any other value not defined in `ListContainersIncludeType`.
    UnknownValue(String),
}

impl<'a> From<&'a ListContainersIncludeType> for &'a str {
    fn from(e: &'a ListContainersIncludeType) -> Self {
        match e {
            ListContainersIncludeType::Deleted => "deleted",
            ListContainersIncludeType::Metadata => "metadata",
            ListContainersIncludeType::System => "system",
            ListContainersIncludeType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ListContainersIncludeType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "deleted" => ListContainersIncludeType::Deleted,
            "metadata" => ListContainersIncludeType::Metadata,
            "system" => ListContainersIncludeType::System,
            _ => ListContainersIncludeType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ListContainersIncludeType {
    fn as_ref(&self) -> &str {
        match self {
            ListContainersIncludeType::Deleted => "deleted",
            ListContainersIncludeType::Metadata => "metadata",
            ListContainersIncludeType::System => "system",
            ListContainersIncludeType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ListContainersIncludeType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ListContainersIncludeType::Deleted => f.write_str("deleted"),
            ListContainersIncludeType::Metadata => f.write_str("metadata"),
            ListContainersIncludeType::System => f.write_str("system"),
            ListContainersIncludeType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for ListContainersIncludeType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for ListContainersIncludeType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The premium page blob access tier types.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum PremiumPageBlobAccessTier {
    /// The premium page blob access tier is P10.
    P10,

    /// The premium page blob access tier is P15.
    P15,

    /// The premium page blob access tier is P20.
    P20,

    /// The premium page blob access tier is P30.
    P30,

    /// The premium page blob access tier is P4.
    P4,

    /// The premium page blob access tier is P40.
    P40,

    /// The premium page blob access tier is P50.
    P50,

    /// The premium page blob access tier is P6.
    P6,

    /// The premium page blob access tier is P60.
    P60,

    /// The premium page blob access tier is P70.
    P70,

    /// The premium page blob access tier is P80.
    P80,

    /// Any other value not defined in `PremiumPageBlobAccessTier`.
    UnknownValue(String),
}

impl<'a> From<&'a PremiumPageBlobAccessTier> for &'a str {
    fn from(e: &'a PremiumPageBlobAccessTier) -> Self {
        match e {
            PremiumPageBlobAccessTier::P10 => "P10",
            PremiumPageBlobAccessTier::P15 => "P15",
            PremiumPageBlobAccessTier::P20 => "P20",
            PremiumPageBlobAccessTier::P30 => "P30",
            PremiumPageBlobAccessTier::P4 => "P4",
            PremiumPageBlobAccessTier::P40 => "P40",
            PremiumPageBlobAccessTier::P50 => "P50",
            PremiumPageBlobAccessTier::P6 => "P6",
            PremiumPageBlobAccessTier::P60 => "P60",
            PremiumPageBlobAccessTier::P70 => "P70",
            PremiumPageBlobAccessTier::P80 => "P80",
            PremiumPageBlobAccessTier::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for PremiumPageBlobAccessTier {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "P10" => PremiumPageBlobAccessTier::P10,
            "P15" => PremiumPageBlobAccessTier::P15,
            "P20" => PremiumPageBlobAccessTier::P20,
            "P30" => PremiumPageBlobAccessTier::P30,
            "P4" => PremiumPageBlobAccessTier::P4,
            "P40" => PremiumPageBlobAccessTier::P40,
            "P50" => PremiumPageBlobAccessTier::P50,
            "P6" => PremiumPageBlobAccessTier::P6,
            "P60" => PremiumPageBlobAccessTier::P60,
            "P70" => PremiumPageBlobAccessTier::P70,
            "P80" => PremiumPageBlobAccessTier::P80,
            _ => PremiumPageBlobAccessTier::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for PremiumPageBlobAccessTier {
    fn as_ref(&self) -> &str {
        match self {
            PremiumPageBlobAccessTier::P10 => "P10",
            PremiumPageBlobAccessTier::P15 => "P15",
            PremiumPageBlobAccessTier::P20 => "P20",
            PremiumPageBlobAccessTier::P30 => "P30",
            PremiumPageBlobAccessTier::P4 => "P4",
            PremiumPageBlobAccessTier::P40 => "P40",
            PremiumPageBlobAccessTier::P50 => "P50",
            PremiumPageBlobAccessTier::P6 => "P6",
            PremiumPageBlobAccessTier::P60 => "P60",
            PremiumPageBlobAccessTier::P70 => "P70",
            PremiumPageBlobAccessTier::P80 => "P80",
            PremiumPageBlobAccessTier::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for PremiumPageBlobAccessTier {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            PremiumPageBlobAccessTier::P10 => f.write_str("P10"),
            PremiumPageBlobAccessTier::P15 => f.write_str("P15"),
            PremiumPageBlobAccessTier::P20 => f.write_str("P20"),
            PremiumPageBlobAccessTier::P30 => f.write_str("P30"),
            PremiumPageBlobAccessTier::P4 => f.write_str("P4"),
            PremiumPageBlobAccessTier::P40 => f.write_str("P40"),
            PremiumPageBlobAccessTier::P50 => f.write_str("P50"),
            PremiumPageBlobAccessTier::P6 => f.write_str("P6"),
            PremiumPageBlobAccessTier::P60 => f.write_str("P60"),
            PremiumPageBlobAccessTier::P70 => f.write_str("P70"),
            PremiumPageBlobAccessTier::P80 => f.write_str("P80"),
            PremiumPageBlobAccessTier::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for PremiumPageBlobAccessTier {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for PremiumPageBlobAccessTier {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The public access types.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum PublicAccessType {
    /// Blob access.
    Blob,

    /// Container access.
    Container,

    /// Any other value not defined in `PublicAccessType`.
    UnknownValue(String),
}

impl<'a> From<&'a PublicAccessType> for &'a str {
    fn from(e: &'a PublicAccessType) -> Self {
        match e {
            PublicAccessType::Blob => "blob",
            PublicAccessType::Container => "container",
            PublicAccessType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for PublicAccessType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "blob" => PublicAccessType::Blob,
            "container" => PublicAccessType::Container,
            _ => PublicAccessType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for PublicAccessType {
    fn as_ref(&self) -> &str {
        match self {
            PublicAccessType::Blob => "blob",
            PublicAccessType::Container => "container",
            PublicAccessType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for PublicAccessType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            PublicAccessType::Blob => f.write_str("blob"),
            PublicAccessType::Container => f.write_str("container"),
            PublicAccessType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for PublicAccessType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for PublicAccessType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The query request, note only SQL supported
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum QueryRequestType {
    /// The SQL request query type.
    Sql,

    /// Any other value not defined in `QueryRequestType`.
    UnknownValue(String),
}

impl<'a> From<&'a QueryRequestType> for &'a str {
    fn from(e: &'a QueryRequestType) -> Self {
        match e {
            QueryRequestType::Sql => "SQL",
            QueryRequestType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for QueryRequestType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "SQL" => QueryRequestType::Sql,
            _ => QueryRequestType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for QueryRequestType {
    fn as_ref(&self) -> &str {
        match self {
            QueryRequestType::Sql => "SQL",
            QueryRequestType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for QueryRequestType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            QueryRequestType::Sql => f.write_str("SQL"),
            QueryRequestType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for QueryRequestType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for QueryRequestType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The query format type.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum QueryType {
    /// The query format type is Apache Arrow.
    Arrow,

    /// The query format type is delimited.
    Delimited,

    /// The query format type is JSON.
    Json,

    /// The query format type is Parquet.
    Parquet,

    /// Any other value not defined in `QueryType`.
    UnknownValue(String),
}

impl<'a> From<&'a QueryType> for &'a str {
    fn from(e: &'a QueryType) -> Self {
        match e {
            QueryType::Arrow => "arrow",
            QueryType::Delimited => "delimited",
            QueryType::Json => "json",
            QueryType::Parquet => "parquet",
            QueryType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for QueryType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "arrow" => QueryType::Arrow,
            "delimited" => QueryType::Delimited,
            "json" => QueryType::Json,
            "parquet" => QueryType::Parquet,
            _ => QueryType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for QueryType {
    fn as_ref(&self) -> &str {
        match self {
            QueryType::Arrow => "arrow",
            QueryType::Delimited => "delimited",
            QueryType::Json => "json",
            QueryType::Parquet => "parquet",
            QueryType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for QueryType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            QueryType::Arrow => f.write_str("arrow"),
            QueryType::Delimited => f.write_str("delimited"),
            QueryType::Json => f.write_str("json"),
            QueryType::Parquet => f.write_str("parquet"),
            QueryType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for QueryType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for QueryType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// If an object is in rehydrate pending state then this header is returned with priority of rehydrate. Valid values are High
/// and Standard.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum RehydratePriority {
    /// The rehydrate priority is high.
    High,

    /// The rehydrate priority is standard.
    Standard,

    /// Any other value not defined in `RehydratePriority`.
    UnknownValue(String),
}

impl<'a> From<&'a RehydratePriority> for &'a str {
    fn from(e: &'a RehydratePriority) -> Self {
        match e {
            RehydratePriority::High => "High",
            RehydratePriority::Standard => "Standard",
            RehydratePriority::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for RehydratePriority {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "High" => RehydratePriority::High,
            "Standard" => RehydratePriority::Standard,
            _ => RehydratePriority::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for RehydratePriority {
    fn as_ref(&self) -> &str {
        match self {
            RehydratePriority::High => "High",
            RehydratePriority::Standard => "Standard",
            RehydratePriority::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for RehydratePriority {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            RehydratePriority::High => f.write_str("High"),
            RehydratePriority::Standard => f.write_str("Standard"),
            RehydratePriority::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for RehydratePriority {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for RehydratePriority {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The sequence number actions.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum SequenceNumberActionType {
    /// Increment the sequence number.
    Increment,

    /// Set the maximum for the sequence number.
    Max,

    /// Update the sequence number.
    Update,

    /// Any other value not defined in `SequenceNumberActionType`.
    UnknownValue(String),
}

impl<'a> From<&'a SequenceNumberActionType> for &'a str {
    fn from(e: &'a SequenceNumberActionType) -> Self {
        match e {
            SequenceNumberActionType::Increment => "increment",
            SequenceNumberActionType::Max => "max",
            SequenceNumberActionType::Update => "update",
            SequenceNumberActionType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for SequenceNumberActionType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "increment" => SequenceNumberActionType::Increment,
            "max" => SequenceNumberActionType::Max,
            "update" => SequenceNumberActionType::Update,
            _ => SequenceNumberActionType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for SequenceNumberActionType {
    fn as_ref(&self) -> &str {
        match self {
            SequenceNumberActionType::Increment => "increment",
            SequenceNumberActionType::Max => "max",
            SequenceNumberActionType::Update => "update",
            SequenceNumberActionType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for SequenceNumberActionType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            SequenceNumberActionType::Increment => f.write_str("increment"),
            SequenceNumberActionType::Max => f.write_str("max"),
            SequenceNumberActionType::Update => f.write_str("update"),
            SequenceNumberActionType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for SequenceNumberActionType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for SequenceNumberActionType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// The SKU types
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum SkuName {
    /// The premium LRS SKU.
    PremiumLrs,

    /// The standard GRS SKU.
    StandardGrs,

    /// The standard LRS SKU.
    StandardLrs,

    /// The standard RAGRS SKU.
    StandardRagrs,

    /// The standard ZRS SKU.
    StandardZrs,

    /// Any other value not defined in `SkuName`.
    UnknownValue(String),
}

impl<'a> From<&'a SkuName> for &'a str {
    fn from(e: &'a SkuName) -> Self {
        match e {
            SkuName::PremiumLrs => "Premium_LRS",
            SkuName::StandardGrs => "Standard_GRS",
            SkuName::StandardLrs => "Standard_LRS",
            SkuName::StandardRagrs => "Standard_RAGRS",
            SkuName::StandardZrs => "Standard_ZRS",
            SkuName::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for SkuName {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Premium_LRS" => SkuName::PremiumLrs,
            "Standard_GRS" => SkuName::StandardGrs,
            "Standard_LRS" => SkuName::StandardLrs,
            "Standard_RAGRS" => SkuName::StandardRagrs,
            "Standard_ZRS" => SkuName::StandardZrs,
            _ => SkuName::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for SkuName {
    fn as_ref(&self) -> &str {
        match self {
            SkuName::PremiumLrs => "Premium_LRS",
            SkuName::StandardGrs => "Standard_GRS",
            SkuName::StandardLrs => "Standard_LRS",
            SkuName::StandardRagrs => "Standard_RAGRS",
            SkuName::StandardZrs => "Standard_ZRS",
            SkuName::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for SkuName {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            SkuName::PremiumLrs => f.write_str("Premium_LRS"),
            SkuName::StandardGrs => f.write_str("Standard_GRS"),
            SkuName::StandardLrs => f.write_str("Standard_LRS"),
            SkuName::StandardRagrs => f.write_str("Standard_RAGRS"),
            SkuName::StandardZrs => f.write_str("Standard_ZRS"),
            SkuName::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for SkuName {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for SkuName {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}
