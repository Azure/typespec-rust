// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::{
    convert::{AsRef, From, Infallible},
    fmt::{Display, Formatter},
    str::FromStr,
};

/// The media type (MIME type).
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum ContentType {
    /// The PEM file format.
    Pem,

    /// The PKCS#12 file format.
    Pfx,

    /// Any other value not defined in `ContentType`.
    UnknownValue(String),
}

impl<'a> From<&'a ContentType> for &'a str {
    fn from(e: &'a ContentType) -> Self {
        match e {
            ContentType::Pem => "application/x-pem-file",
            ContentType::Pfx => "application/x-pkcs12",
            ContentType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ContentType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "application/x-pem-file" => ContentType::Pem,
            "application/x-pkcs12" => ContentType::Pfx,
            _ => ContentType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ContentType {
    fn as_ref(&self) -> &str {
        match self {
            ContentType::Pem => "application/x-pem-file",
            ContentType::Pfx => "application/x-pkcs12",
            ContentType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ContentType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ContentType::Pem => f.write_str("application/x-pem-file"),
            ContentType::Pfx => f.write_str("application/x-pkcs12"),
            ContentType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for ContentType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for ContentType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}

/// Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains 'Purgeable',
/// the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end
/// of the retention interval.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum DeletionRecoveryLevel {
    /// Denotes a vault state in which deletion is recoverable without the possibility for immediate and permanent deletion (i.e.
    /// purge when 7 <= SoftDeleteRetentionInDays < 90).This level guarantees the recoverability of the deleted entity during
    /// the retention interval and while the subscription is still available.
    CustomizedRecoverable,

    /// Denotes a vault and subscription state in which deletion is recoverable, immediate and permanent deletion (i.e. purge)
    /// is not permitted, and in which the subscription itself cannot be permanently canceled when 7 <= SoftDeleteRetentionInDays
    /// < 90. This level guarantees the recoverability of the deleted entity during the retention interval, and also reflects
    /// the fact that the subscription itself cannot be cancelled.
    CustomizedRecoverableProtectedSubscription,

    /// Denotes a vault state in which deletion is recoverable, and which also permits immediate and permanent deletion (i.e.
    /// purge when 7 <= SoftDeleteRetentionInDays < 90). This level guarantees the recoverability of the deleted entity during
    /// the retention interval, unless a Purge operation is requested, or the subscription is cancelled.
    CustomizedRecoverablePurgeable,

    /// Denotes a vault state in which deletion is an irreversible operation, without the possibility for recovery. This level
    /// corresponds to no protection being available against a Delete operation; the data is irretrievably lost upon accepting
    /// a Delete operation at the entity level or higher (vault, resource group, subscription etc.)
    Purgeable,

    /// Denotes a vault state in which deletion is recoverable without the possibility for immediate and permanent deletion (i.e.
    /// purge). This level guarantees the recoverability of the deleted entity during the retention interval (90 days) and while
    /// the subscription is still available. System wil permanently delete it after 90 days, if not recovered
    Recoverable,

    /// Denotes a vault and subscription state in which deletion is recoverable within retention interval (90 days), immediate
    /// and permanent deletion (i.e. purge) is not permitted, and in which the subscription itself cannot be permanently canceled.
    /// System wil permanently delete it after 90 days, if not recovered
    RecoverableProtectedSubscription,

    /// Denotes a vault state in which deletion is recoverable, and which also permits immediate and permanent deletion (i.e.
    /// purge). This level guarantees the recoverability of the deleted entity during the retention interval (90 days), unless
    /// a Purge operation is requested, or the subscription is cancelled. System wil permanently delete it after 90 days, if not
    /// recovered
    RecoverablePurgeable,

    /// Any other value not defined in `DeletionRecoveryLevel`.
    UnknownValue(String),
}

impl<'a> From<&'a DeletionRecoveryLevel> for &'a str {
    fn from(e: &'a DeletionRecoveryLevel) -> Self {
        match e {
            DeletionRecoveryLevel::CustomizedRecoverable => "CustomizedRecoverable",
            DeletionRecoveryLevel::CustomizedRecoverableProtectedSubscription => {
                "CustomizedRecoverable+ProtectedSubscription"
            }
            DeletionRecoveryLevel::CustomizedRecoverablePurgeable => {
                "CustomizedRecoverable+Purgeable"
            }
            DeletionRecoveryLevel::Purgeable => "Purgeable",
            DeletionRecoveryLevel::Recoverable => "Recoverable",
            DeletionRecoveryLevel::RecoverableProtectedSubscription => {
                "Recoverable+ProtectedSubscription"
            }
            DeletionRecoveryLevel::RecoverablePurgeable => "Recoverable+Purgeable",
            DeletionRecoveryLevel::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for DeletionRecoveryLevel {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "CustomizedRecoverable" => DeletionRecoveryLevel::CustomizedRecoverable,
            "CustomizedRecoverable+ProtectedSubscription" => {
                DeletionRecoveryLevel::CustomizedRecoverableProtectedSubscription
            }
            "CustomizedRecoverable+Purgeable" => {
                DeletionRecoveryLevel::CustomizedRecoverablePurgeable
            }
            "Purgeable" => DeletionRecoveryLevel::Purgeable,
            "Recoverable" => DeletionRecoveryLevel::Recoverable,
            "Recoverable+ProtectedSubscription" => {
                DeletionRecoveryLevel::RecoverableProtectedSubscription
            }
            "Recoverable+Purgeable" => DeletionRecoveryLevel::RecoverablePurgeable,
            _ => DeletionRecoveryLevel::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for DeletionRecoveryLevel {
    fn as_ref(&self) -> &str {
        match self {
            DeletionRecoveryLevel::CustomizedRecoverable => "CustomizedRecoverable",
            DeletionRecoveryLevel::CustomizedRecoverableProtectedSubscription => {
                "CustomizedRecoverable+ProtectedSubscription"
            }
            DeletionRecoveryLevel::CustomizedRecoverablePurgeable => {
                "CustomizedRecoverable+Purgeable"
            }
            DeletionRecoveryLevel::Purgeable => "Purgeable",
            DeletionRecoveryLevel::Recoverable => "Recoverable",
            DeletionRecoveryLevel::RecoverableProtectedSubscription => {
                "Recoverable+ProtectedSubscription"
            }
            DeletionRecoveryLevel::RecoverablePurgeable => "Recoverable+Purgeable",
            DeletionRecoveryLevel::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for DeletionRecoveryLevel {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            DeletionRecoveryLevel::CustomizedRecoverable => f.write_str("CustomizedRecoverable"),
            DeletionRecoveryLevel::CustomizedRecoverableProtectedSubscription => {
                f.write_str("CustomizedRecoverable+ProtectedSubscription")
            }
            DeletionRecoveryLevel::CustomizedRecoverablePurgeable => {
                f.write_str("CustomizedRecoverable+Purgeable")
            }
            DeletionRecoveryLevel::Purgeable => f.write_str("Purgeable"),
            DeletionRecoveryLevel::Recoverable => f.write_str("Recoverable"),
            DeletionRecoveryLevel::RecoverableProtectedSubscription => {
                f.write_str("Recoverable+ProtectedSubscription")
            }
            DeletionRecoveryLevel::RecoverablePurgeable => f.write_str("Recoverable+Purgeable"),
            DeletionRecoveryLevel::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for DeletionRecoveryLevel {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for DeletionRecoveryLevel {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        s.serialize_str(self.as_ref())
    }
}
