// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use azure_core::error::{Error, ErrorKind};
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::{
    convert::{AsRef, From, Infallible},
    fmt::{Display, Formatter},
    str::FromStr,
};

/// Composition types.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum CompositionType {
    /// The 'key' composition type.
    Key,

    /// The 'key_label' composition type.
    KeyLabel,
    /// Any other value not defined in `CompositionType`.
    UnknownValue(String),
}

impl<'a> From<&'a CompositionType> for &'a str {
    fn from(e: &'a CompositionType) -> Self {
        match e {
            CompositionType::Key => "key",
            CompositionType::KeyLabel => "key_label",
            CompositionType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for CompositionType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "key" => CompositionType::Key,
            "key_label" => CompositionType::KeyLabel,
            _ => CompositionType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for CompositionType {
    fn as_ref(&self) -> &str {
        match self {
            CompositionType::Key => "key",
            CompositionType::KeyLabel => "key_label",
            CompositionType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for CompositionType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            CompositionType::Key => f.write_str("key"),
            CompositionType::KeyLabel => f.write_str("key_label"),
            CompositionType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for CompositionType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for CompositionType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
#[non_exhaustive]
pub enum CreateSnapshotRequestContentType {
    ApplicationJson,

    ApplicationVndMicrosoftAppconfigSnapshotJson,
}

impl FromStr for CreateSnapshotRequestContentType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "application/json" => CreateSnapshotRequestContentType::ApplicationJson,
            "application/vnd.microsoft.appconfig.snapshot+json" => {
                CreateSnapshotRequestContentType::ApplicationVndMicrosoftAppconfigSnapshotJson
            }
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of CreateSnapshotRequestContentType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for CreateSnapshotRequestContentType {
    fn as_ref(&self) -> &str {
        match self {
            CreateSnapshotRequestContentType::ApplicationJson => "application/json",
            CreateSnapshotRequestContentType::ApplicationVndMicrosoftAppconfigSnapshotJson => {
                "application/vnd.microsoft.appconfig.snapshot+json"
            }
        }
    }
}

impl Display for CreateSnapshotRequestContentType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            CreateSnapshotRequestContentType::ApplicationJson => {
                Display::fmt("application/json", f)
            }
            CreateSnapshotRequestContentType::ApplicationVndMicrosoftAppconfigSnapshotJson => {
                Display::fmt("application/vnd.microsoft.appconfig.snapshot+json", f)
            }
        }
    }
}

impl<'de> Deserialize<'de> for CreateSnapshotRequestContentType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for CreateSnapshotRequestContentType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
#[non_exhaustive]
pub enum GetKeyValueResponseContentType {
    ApplicationProblemJson,

    ApplicationVndMicrosoftAppconfigKvJson,
}

impl FromStr for GetKeyValueResponseContentType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "application/problem+json" => GetKeyValueResponseContentType::ApplicationProblemJson,
            "application/vnd.microsoft.appconfig.kv+json" => {
                GetKeyValueResponseContentType::ApplicationVndMicrosoftAppconfigKvJson
            }
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of GetKeyValueResponseContentType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for GetKeyValueResponseContentType {
    fn as_ref(&self) -> &str {
        match self {
            GetKeyValueResponseContentType::ApplicationProblemJson => "application/problem+json",
            GetKeyValueResponseContentType::ApplicationVndMicrosoftAppconfigKvJson => {
                "application/vnd.microsoft.appconfig.kv+json"
            }
        }
    }
}

impl Display for GetKeyValueResponseContentType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            GetKeyValueResponseContentType::ApplicationProblemJson => {
                Display::fmt("application/problem+json", f)
            }
            GetKeyValueResponseContentType::ApplicationVndMicrosoftAppconfigKvJson => {
                Display::fmt("application/vnd.microsoft.appconfig.kv+json", f)
            }
        }
    }
}

impl<'de> Deserialize<'de> for GetKeyValueResponseContentType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for GetKeyValueResponseContentType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
#[non_exhaustive]
pub enum GetKeyValuesResponseContentType {
    ApplicationProblemJson,

    ApplicationVndMicrosoftAppconfigKvsetJson,
}

impl FromStr for GetKeyValuesResponseContentType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "application/problem+json" => GetKeyValuesResponseContentType::ApplicationProblemJson,
            "application/vnd.microsoft.appconfig.kvset+json" => {
                GetKeyValuesResponseContentType::ApplicationVndMicrosoftAppconfigKvsetJson
            }
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of GetKeyValuesResponseContentType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for GetKeyValuesResponseContentType {
    fn as_ref(&self) -> &str {
        match self {
            GetKeyValuesResponseContentType::ApplicationProblemJson => "application/problem+json",
            GetKeyValuesResponseContentType::ApplicationVndMicrosoftAppconfigKvsetJson => {
                "application/vnd.microsoft.appconfig.kvset+json"
            }
        }
    }
}

impl Display for GetKeyValuesResponseContentType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            GetKeyValuesResponseContentType::ApplicationProblemJson => {
                Display::fmt("application/problem+json", f)
            }
            GetKeyValuesResponseContentType::ApplicationVndMicrosoftAppconfigKvsetJson => {
                Display::fmt("application/vnd.microsoft.appconfig.kvset+json", f)
            }
        }
    }
}

impl<'de> Deserialize<'de> for GetKeyValuesResponseContentType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for GetKeyValuesResponseContentType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
#[non_exhaustive]
pub enum GetKeysResponseContentType {
    ApplicationProblemJson,

    ApplicationVndMicrosoftAppconfigKeysetJson,
}

impl FromStr for GetKeysResponseContentType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "application/problem+json" => GetKeysResponseContentType::ApplicationProblemJson,
            "application/vnd.microsoft.appconfig.keyset+json" => {
                GetKeysResponseContentType::ApplicationVndMicrosoftAppconfigKeysetJson
            }
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of GetKeysResponseContentType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for GetKeysResponseContentType {
    fn as_ref(&self) -> &str {
        match self {
            GetKeysResponseContentType::ApplicationProblemJson => "application/problem+json",
            GetKeysResponseContentType::ApplicationVndMicrosoftAppconfigKeysetJson => {
                "application/vnd.microsoft.appconfig.keyset+json"
            }
        }
    }
}

impl Display for GetKeysResponseContentType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            GetKeysResponseContentType::ApplicationProblemJson => {
                Display::fmt("application/problem+json", f)
            }
            GetKeysResponseContentType::ApplicationVndMicrosoftAppconfigKeysetJson => {
                Display::fmt("application/vnd.microsoft.appconfig.keyset+json", f)
            }
        }
    }
}

impl<'de> Deserialize<'de> for GetKeysResponseContentType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for GetKeysResponseContentType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
#[non_exhaustive]
pub enum GetLabelsResponseContentType {
    ApplicationProblemJson,

    ApplicationVndMicrosoftAppconfigLabelsetJson,
}

impl FromStr for GetLabelsResponseContentType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "application/problem+json" => GetLabelsResponseContentType::ApplicationProblemJson,
            "application/vnd.microsoft.appconfig.labelset+json" => {
                GetLabelsResponseContentType::ApplicationVndMicrosoftAppconfigLabelsetJson
            }
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of GetLabelsResponseContentType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for GetLabelsResponseContentType {
    fn as_ref(&self) -> &str {
        match self {
            GetLabelsResponseContentType::ApplicationProblemJson => "application/problem+json",
            GetLabelsResponseContentType::ApplicationVndMicrosoftAppconfigLabelsetJson => {
                "application/vnd.microsoft.appconfig.labelset+json"
            }
        }
    }
}

impl Display for GetLabelsResponseContentType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            GetLabelsResponseContentType::ApplicationProblemJson => {
                Display::fmt("application/problem+json", f)
            }
            GetLabelsResponseContentType::ApplicationVndMicrosoftAppconfigLabelsetJson => {
                Display::fmt("application/vnd.microsoft.appconfig.labelset+json", f)
            }
        }
    }
}

impl<'de> Deserialize<'de> for GetLabelsResponseContentType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for GetLabelsResponseContentType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
#[non_exhaustive]
pub enum GetSnapshotResponseContentType {
    ApplicationProblemJson,

    ApplicationVndMicrosoftAppconfigSnapshotJson,
}

impl FromStr for GetSnapshotResponseContentType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "application/problem+json" => GetSnapshotResponseContentType::ApplicationProblemJson,
            "application/vnd.microsoft.appconfig.snapshot+json" => {
                GetSnapshotResponseContentType::ApplicationVndMicrosoftAppconfigSnapshotJson
            }
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of GetSnapshotResponseContentType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for GetSnapshotResponseContentType {
    fn as_ref(&self) -> &str {
        match self {
            GetSnapshotResponseContentType::ApplicationProblemJson => "application/problem+json",
            GetSnapshotResponseContentType::ApplicationVndMicrosoftAppconfigSnapshotJson => {
                "application/vnd.microsoft.appconfig.snapshot+json"
            }
        }
    }
}

impl Display for GetSnapshotResponseContentType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            GetSnapshotResponseContentType::ApplicationProblemJson => {
                Display::fmt("application/problem+json", f)
            }
            GetSnapshotResponseContentType::ApplicationVndMicrosoftAppconfigSnapshotJson => {
                Display::fmt("application/vnd.microsoft.appconfig.snapshot+json", f)
            }
        }
    }
}

impl<'de> Deserialize<'de> for GetSnapshotResponseContentType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for GetSnapshotResponseContentType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
#[non_exhaustive]
pub enum GetSnapshotsResponseContentType {
    ApplicationProblemJson,

    ApplicationVndMicrosoftAppconfigSnapshotsetJson,
}

impl FromStr for GetSnapshotsResponseContentType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "application/problem+json" => GetSnapshotsResponseContentType::ApplicationProblemJson,
            "application/vnd.microsoft.appconfig.snapshotset+json" => {
                GetSnapshotsResponseContentType::ApplicationVndMicrosoftAppconfigSnapshotsetJson
            }
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of GetSnapshotsResponseContentType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for GetSnapshotsResponseContentType {
    fn as_ref(&self) -> &str {
        match self {
            GetSnapshotsResponseContentType::ApplicationProblemJson => "application/problem+json",
            GetSnapshotsResponseContentType::ApplicationVndMicrosoftAppconfigSnapshotsetJson => {
                "application/vnd.microsoft.appconfig.snapshotset+json"
            }
        }
    }
}

impl Display for GetSnapshotsResponseContentType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            GetSnapshotsResponseContentType::ApplicationProblemJson => {
                Display::fmt("application/problem+json", f)
            }
            GetSnapshotsResponseContentType::ApplicationVndMicrosoftAppconfigSnapshotsetJson => {
                Display::fmt("application/vnd.microsoft.appconfig.snapshotset+json", f)
            }
        }
    }
}

impl<'de> Deserialize<'de> for GetSnapshotsResponseContentType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for GetSnapshotsResponseContentType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}

/// Key-value fields.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum KeyValueFields {
    /// Content type field.
    ContentType,

    /// Etag field.
    Etag,

    /// Key field.
    Key,

    /// Label field.
    Label,

    /// Last modified field.
    LastModified,

    /// Locked field.
    Locked,

    /// Tags field.
    Tags,

    /// Value field.
    Value,
    /// Any other value not defined in `KeyValueFields`.
    UnknownValue(String),
}

impl<'a> From<&'a KeyValueFields> for &'a str {
    fn from(e: &'a KeyValueFields) -> Self {
        match e {
            KeyValueFields::ContentType => "content_type",
            KeyValueFields::Etag => "etag",
            KeyValueFields::Key => "key",
            KeyValueFields::Label => "label",
            KeyValueFields::LastModified => "last_modified",
            KeyValueFields::Locked => "locked",
            KeyValueFields::Tags => "tags",
            KeyValueFields::Value => "value",
            KeyValueFields::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for KeyValueFields {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "content_type" => KeyValueFields::ContentType,
            "etag" => KeyValueFields::Etag,
            "key" => KeyValueFields::Key,
            "label" => KeyValueFields::Label,
            "last_modified" => KeyValueFields::LastModified,
            "locked" => KeyValueFields::Locked,
            "tags" => KeyValueFields::Tags,
            "value" => KeyValueFields::Value,
            _ => KeyValueFields::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for KeyValueFields {
    fn as_ref(&self) -> &str {
        match self {
            KeyValueFields::ContentType => "content_type",
            KeyValueFields::Etag => "etag",
            KeyValueFields::Key => "key",
            KeyValueFields::Label => "label",
            KeyValueFields::LastModified => "last_modified",
            KeyValueFields::Locked => "locked",
            KeyValueFields::Tags => "tags",
            KeyValueFields::Value => "value",
            KeyValueFields::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for KeyValueFields {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            KeyValueFields::ContentType => f.write_str("content_type"),
            KeyValueFields::Etag => f.write_str("etag"),
            KeyValueFields::Key => f.write_str("key"),
            KeyValueFields::Label => f.write_str("label"),
            KeyValueFields::LastModified => f.write_str("last_modified"),
            KeyValueFields::Locked => f.write_str("locked"),
            KeyValueFields::Tags => f.write_str("tags"),
            KeyValueFields::Value => f.write_str("value"),
            KeyValueFields::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for KeyValueFields {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for KeyValueFields {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}

/// Label fields.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum LabelFields {
    /// Name field.
    Name,
    /// Any other value not defined in `LabelFields`.
    UnknownValue(String),
}

impl<'a> From<&'a LabelFields> for &'a str {
    fn from(e: &'a LabelFields) -> Self {
        match e {
            LabelFields::Name => "name",
            LabelFields::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for LabelFields {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "name" => LabelFields::Name,
            _ => LabelFields::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for LabelFields {
    fn as_ref(&self) -> &str {
        match self {
            LabelFields::Name => "name",
            LabelFields::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for LabelFields {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            LabelFields::Name => f.write_str("name"),
            LabelFields::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for LabelFields {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for LabelFields {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}

/// Enum describing allowed operation states.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum OperationState {
    /// The operation has been canceled by the user.
    Canceled,

    /// The operation has failed.
    Failed,

    /// The operation has not started.
    NotStarted,

    /// The operation is in progress.
    Running,

    /// The operation has completed successfully.
    Succeeded,
    /// Any other value not defined in `OperationState`.
    UnknownValue(String),
}

impl<'a> From<&'a OperationState> for &'a str {
    fn from(e: &'a OperationState) -> Self {
        match e {
            OperationState::Canceled => "Canceled",
            OperationState::Failed => "Failed",
            OperationState::NotStarted => "NotStarted",
            OperationState::Running => "Running",
            OperationState::Succeeded => "Succeeded",
            OperationState::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for OperationState {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Canceled" => OperationState::Canceled,
            "Failed" => OperationState::Failed,
            "NotStarted" => OperationState::NotStarted,
            "Running" => OperationState::Running,
            "Succeeded" => OperationState::Succeeded,
            _ => OperationState::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for OperationState {
    fn as_ref(&self) -> &str {
        match self {
            OperationState::Canceled => "Canceled",
            OperationState::Failed => "Failed",
            OperationState::NotStarted => "NotStarted",
            OperationState::Running => "Running",
            OperationState::Succeeded => "Succeeded",
            OperationState::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for OperationState {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            OperationState::Canceled => f.write_str("Canceled"),
            OperationState::Failed => f.write_str("Failed"),
            OperationState::NotStarted => f.write_str("NotStarted"),
            OperationState::Running => f.write_str("Running"),
            OperationState::Succeeded => f.write_str("Succeeded"),
            OperationState::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for OperationState {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for OperationState {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
#[non_exhaustive]
pub enum PutKeyValueRequestContentType {
    ApplicationAnyJson,

    ApplicationJson,

    ApplicationJsonPatchJson,

    ApplicationVndMicrosoftAppconfigKvJson,

    ApplicationVndMicrosoftAppconfigKvsetJson,

    TextJson,
}

impl FromStr for PutKeyValueRequestContentType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "application/*+json" => PutKeyValueRequestContentType::ApplicationAnyJson,
            "application/json" => PutKeyValueRequestContentType::ApplicationJson,
            "application/json-patch+json" => {
                PutKeyValueRequestContentType::ApplicationJsonPatchJson
            }
            "application/vnd.microsoft.appconfig.kv+json" => {
                PutKeyValueRequestContentType::ApplicationVndMicrosoftAppconfigKvJson
            }
            "application/vnd.microsoft.appconfig.kvset+json" => {
                PutKeyValueRequestContentType::ApplicationVndMicrosoftAppconfigKvsetJson
            }
            "text/json" => PutKeyValueRequestContentType::TextJson,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of PutKeyValueRequestContentType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for PutKeyValueRequestContentType {
    fn as_ref(&self) -> &str {
        match self {
            PutKeyValueRequestContentType::ApplicationAnyJson => "application/*+json",
            PutKeyValueRequestContentType::ApplicationJson => "application/json",
            PutKeyValueRequestContentType::ApplicationJsonPatchJson => {
                "application/json-patch+json"
            }
            PutKeyValueRequestContentType::ApplicationVndMicrosoftAppconfigKvJson => {
                "application/vnd.microsoft.appconfig.kv+json"
            }
            PutKeyValueRequestContentType::ApplicationVndMicrosoftAppconfigKvsetJson => {
                "application/vnd.microsoft.appconfig.kvset+json"
            }
            PutKeyValueRequestContentType::TextJson => "text/json",
        }
    }
}

impl Display for PutKeyValueRequestContentType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            PutKeyValueRequestContentType::ApplicationAnyJson => {
                Display::fmt("application/*+json", f)
            }
            PutKeyValueRequestContentType::ApplicationJson => Display::fmt("application/json", f),
            PutKeyValueRequestContentType::ApplicationJsonPatchJson => {
                Display::fmt("application/json-patch+json", f)
            }
            PutKeyValueRequestContentType::ApplicationVndMicrosoftAppconfigKvJson => {
                Display::fmt("application/vnd.microsoft.appconfig.kv+json", f)
            }
            PutKeyValueRequestContentType::ApplicationVndMicrosoftAppconfigKvsetJson => {
                Display::fmt("application/vnd.microsoft.appconfig.kvset+json", f)
            }
            PutKeyValueRequestContentType::TextJson => Display::fmt("text/json", f),
        }
    }
}

impl<'de> Deserialize<'de> for PutKeyValueRequestContentType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for PutKeyValueRequestContentType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}

/// Snapshot fields.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum SnapshotFields {
    /// Composition type field.
    CompositionType,

    /// Created field.
    Created,

    /// Etag field.
    Etag,

    /// Expires field.
    Expires,

    /// Filters field.
    Filters,

    /// Items count field.
    ItemsCount,

    /// Name field.
    Name,

    /// Retention period field.
    RetentionPeriod,

    /// Size field.
    Size,

    /// Status field.
    Status,

    /// Tags field.
    Tags,
    /// Any other value not defined in `SnapshotFields`.
    UnknownValue(String),
}

impl<'a> From<&'a SnapshotFields> for &'a str {
    fn from(e: &'a SnapshotFields) -> Self {
        match e {
            SnapshotFields::CompositionType => "composition_type",
            SnapshotFields::Created => "created",
            SnapshotFields::Etag => "etag",
            SnapshotFields::Expires => "expires",
            SnapshotFields::Filters => "filters",
            SnapshotFields::ItemsCount => "items_count",
            SnapshotFields::Name => "name",
            SnapshotFields::RetentionPeriod => "retention_period",
            SnapshotFields::Size => "size",
            SnapshotFields::Status => "status",
            SnapshotFields::Tags => "tags",
            SnapshotFields::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for SnapshotFields {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "composition_type" => SnapshotFields::CompositionType,
            "created" => SnapshotFields::Created,
            "etag" => SnapshotFields::Etag,
            "expires" => SnapshotFields::Expires,
            "filters" => SnapshotFields::Filters,
            "items_count" => SnapshotFields::ItemsCount,
            "name" => SnapshotFields::Name,
            "retention_period" => SnapshotFields::RetentionPeriod,
            "size" => SnapshotFields::Size,
            "status" => SnapshotFields::Status,
            "tags" => SnapshotFields::Tags,
            _ => SnapshotFields::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for SnapshotFields {
    fn as_ref(&self) -> &str {
        match self {
            SnapshotFields::CompositionType => "composition_type",
            SnapshotFields::Created => "created",
            SnapshotFields::Etag => "etag",
            SnapshotFields::Expires => "expires",
            SnapshotFields::Filters => "filters",
            SnapshotFields::ItemsCount => "items_count",
            SnapshotFields::Name => "name",
            SnapshotFields::RetentionPeriod => "retention_period",
            SnapshotFields::Size => "size",
            SnapshotFields::Status => "status",
            SnapshotFields::Tags => "tags",
            SnapshotFields::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for SnapshotFields {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            SnapshotFields::CompositionType => f.write_str("composition_type"),
            SnapshotFields::Created => f.write_str("created"),
            SnapshotFields::Etag => f.write_str("etag"),
            SnapshotFields::Expires => f.write_str("expires"),
            SnapshotFields::Filters => f.write_str("filters"),
            SnapshotFields::ItemsCount => f.write_str("items_count"),
            SnapshotFields::Name => f.write_str("name"),
            SnapshotFields::RetentionPeriod => f.write_str("retention_period"),
            SnapshotFields::Size => f.write_str("size"),
            SnapshotFields::Status => f.write_str("status"),
            SnapshotFields::Tags => f.write_str("tags"),
            SnapshotFields::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for SnapshotFields {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for SnapshotFields {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}

/// Snapshot status.
#[derive(Debug, PartialEq, Eq, Clone)]
#[non_exhaustive]
pub enum SnapshotStatus {
    /// Archived
    Archived,

    /// Failed
    Failed,

    /// Provisioning
    Provisioning,

    /// Ready
    Ready,
    /// Any other value not defined in `SnapshotStatus`.
    UnknownValue(String),
}

impl<'a> From<&'a SnapshotStatus> for &'a str {
    fn from(e: &'a SnapshotStatus) -> Self {
        match e {
            SnapshotStatus::Archived => "archived",
            SnapshotStatus::Failed => "failed",
            SnapshotStatus::Provisioning => "provisioning",
            SnapshotStatus::Ready => "ready",
            SnapshotStatus::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for SnapshotStatus {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "archived" => SnapshotStatus::Archived,
            "failed" => SnapshotStatus::Failed,
            "provisioning" => SnapshotStatus::Provisioning,
            "ready" => SnapshotStatus::Ready,
            _ => SnapshotStatus::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for SnapshotStatus {
    fn as_ref(&self) -> &str {
        match self {
            SnapshotStatus::Archived => "archived",
            SnapshotStatus::Failed => "failed",
            SnapshotStatus::Provisioning => "provisioning",
            SnapshotStatus::Ready => "ready",
            SnapshotStatus::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for SnapshotStatus {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            SnapshotStatus::Archived => f.write_str("archived"),
            SnapshotStatus::Failed => f.write_str("failed"),
            SnapshotStatus::Provisioning => f.write_str("provisioning"),
            SnapshotStatus::Ready => f.write_str("ready"),
            SnapshotStatus::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'de> Deserialize<'de> for SnapshotStatus {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for SnapshotStatus {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
#[non_exhaustive]
pub enum UpdateSnapshotRequestContentType {
    ApplicationJson,

    ApplicationMergePatchJson,
}

impl FromStr for UpdateSnapshotRequestContentType {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "application/json" => UpdateSnapshotRequestContentType::ApplicationJson,
            "application/merge-patch+json" => {
                UpdateSnapshotRequestContentType::ApplicationMergePatchJson
            }
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of UpdateSnapshotRequestContentType found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for UpdateSnapshotRequestContentType {
    fn as_ref(&self) -> &str {
        match self {
            UpdateSnapshotRequestContentType::ApplicationJson => "application/json",
            UpdateSnapshotRequestContentType::ApplicationMergePatchJson => {
                "application/merge-patch+json"
            }
        }
    }
}

impl Display for UpdateSnapshotRequestContentType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            UpdateSnapshotRequestContentType::ApplicationJson => {
                Display::fmt("application/json", f)
            }
            UpdateSnapshotRequestContentType::ApplicationMergePatchJson => {
                Display::fmt("application/merge-patch+json", f)
            }
        }
    }
}

impl<'de> Deserialize<'de> for UpdateSnapshotRequestContentType {
    fn deserialize<D>(deserializer: D) -> ::core::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl Serialize for UpdateSnapshotRequestContentType {
    fn serialize<S>(&self, s: S) -> ::core::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        return s.serialize_str(&self.to_string());
    }
}
