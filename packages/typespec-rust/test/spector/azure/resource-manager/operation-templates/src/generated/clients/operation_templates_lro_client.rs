// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use azure_core::{Result, http::{Method, Pipeline, Poller, PollerStatus, RawResponse, Request, RequestContent, Url, poller::{PollerResult, PollerState, StatusMonitor as _, get_retry_after, }, }, json, tracing, };
use crate::generated::models::{ArmOperationStatusResourceProvisioningState, ExportRequest, ExportResult, OperationTemplatesLroClientBeginCreateOrReplaceOptions, OperationTemplatesLroClientBeginDeleteOptions, OperationTemplatesLroClientBeginExportOptions, OperationTemplatesLroClientResumeArmOperationStatusResourceProvisioningStateOperationOptions, OperationTemplatesLroClientResumeExportResultOperationOptions, OperationTemplatesLroClientResumeOrderOperationOptions, Order, };

#[tracing::client]
pub struct OperationTemplatesLroClient {
    pub(crate) api_version: String,
    pub(crate) endpoint: Url,
    pub(crate) pipeline: Pipeline,
    pub(crate) subscription_id: String,
}

impl OperationTemplatesLroClient {
    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    /// Create a Order
    ///
    /// # Arguments
    ///
/// * `resource_group_name` - The name of the resource group. The name is case insensitive.
/// * `order_name` - The name of the Order
/// * `resource` - Resource create parameters.
/// * `options` - Optional parameters for the request.
    #[tracing::function("Azure.ResourceManager.OperationTemplates.Lro.createOrReplace")]
    pub fn begin_create_or_replace(&self, resource_group_name: &str, order_name: &str, resource: RequestContent<Order>, options: Option<OperationTemplatesLroClientBeginCreateOrReplaceOptions<'_>>) -> Result<Poller<Order>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut url = self.endpoint.clone();
        let mut path = String::from("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Azure.ResourceManager.OperationTemplates/orders/{orderName}");
        path = path.replace("{orderName}", order_name);
        path = path.replace("{resourceGroupName}", resource_group_name);
        path = path.replace("{subscriptionId}", &self.subscription_id);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);


        let api_version = self.api_version.clone();

        Ok(Poller::from_callback(
            move |next_link: PollerState<Url>| {
                let (mut request, next_link) = match next_link {
                    PollerState::More(next_link) => {
                        let qp = next_link.query_pairs().filter(|(name, _)| name.ne("api-version"));
                        let mut next_link = next_link.clone();
                        next_link.query_pairs_mut().clear().extend_pairs(qp).append_pair("api-version", &api_version);

                        let mut request = Request::new(next_link.clone(), Method::Get);
                        request.insert_header("accept", "application/json");
                        request.insert_header("content-type", "application/json");


                        (request, next_link)
                    },
                    PollerState::Initial => {
                        let mut request = Request::new(url.clone(), Method::Put);
                        request.insert_header("accept", "application/json");
                        request.insert_header("content-type", "application/json");
                        request.set_body(resource.clone());

                        (request, url.clone())
                    },
                };

                let ctx = options.method_options.context.clone();
                let pipeline = pipeline.clone();
                async move {
                    let rsp: RawResponse = pipeline.send(&ctx, &mut request).await?;
                    let (status, headers, body) = rsp.deconstruct();
                    let retry_after = get_retry_after(&headers, &options.poller_options);
                    let bytes = body.collect().await?;
                    let res: Order = json::from_json(&bytes)?;
                    let rsp = RawResponse::from_bytes(status, headers, bytes).into();
                    Ok(match res.status() {
                        PollerStatus::InProgress => PollerResult::InProgress {
                            response: rsp, retry_after, next: next_link
                        },
                        _ => PollerResult::Done {
                            response: rsp                        },
                    })
                }
            },
            None,
        ))
    }

    /// Delete a Order
    ///
    /// # Arguments
    ///
/// * `resource_group_name` - The name of the resource group. The name is case insensitive.
/// * `order_name` - The name of the Order
/// * `options` - Optional parameters for the request.
    #[tracing::function("Azure.ResourceManager.OperationTemplates.Lro.delete")]
    pub fn begin_delete(&self, resource_group_name: &str, order_name: &str, options: Option<OperationTemplatesLroClientBeginDeleteOptions<'_>>) -> Result<Poller<ArmOperationStatusResourceProvisioningState>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut url = self.endpoint.clone();
        let mut path = String::from("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Azure.ResourceManager.OperationTemplates/orders/{orderName}");
        path = path.replace("{orderName}", order_name);
        path = path.replace("{resourceGroupName}", resource_group_name);
        path = path.replace("{subscriptionId}", &self.subscription_id);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);


        let api_version = self.api_version.clone();

        Ok(Poller::from_callback(
            move |next_link: PollerState<Url>| {
                let (mut request, next_link) = match next_link {
                    PollerState::More(next_link) => {
                        let qp = next_link.query_pairs().filter(|(name, _)| name.ne("api-version"));
                        let mut next_link = next_link.clone();
                        next_link.query_pairs_mut().clear().extend_pairs(qp).append_pair("api-version", &api_version);

                        let request = Request::new(next_link.clone(), Method::Get);


                        (request, next_link)
                    },
                    PollerState::Initial => {
                        let mut request = Request::new(url.clone(), Method::Delete);

                        (request, url.clone())
                    },
                };

                let ctx = options.method_options.context.clone();
                let pipeline = pipeline.clone();
                async move {
                    let rsp: RawResponse = pipeline.send(&ctx, &mut request).await?;
                    let (status, headers, body) = rsp.deconstruct();
                    let retry_after = get_retry_after(&headers, &options.poller_options);
                    let bytes = body.collect().await?;
                    let res: ArmOperationStatusResourceProvisioningState = json::from_json(&bytes)?;
                    let rsp = RawResponse::from_bytes(status, headers, bytes).into();
                    Ok(match res.status() {
                        PollerStatus::InProgress => PollerResult::InProgress {
                            response: rsp, retry_after, next: next_link
                        },
                        _ => PollerResult::Done {
                            response: rsp                        },
                    })
                }
            },
            None,
        ))
    }

    /// A long-running resource action.
    ///
    /// # Arguments
    ///
/// * `resource_group_name` - The name of the resource group. The name is case insensitive.
/// * `order_name` - The name of the Order
/// * `body` - The content of the action request
/// * `options` - Optional parameters for the request.
    #[tracing::function("Azure.ResourceManager.OperationTemplates.Lro.export")]
    pub fn begin_export(&self, resource_group_name: &str, order_name: &str, body: RequestContent<ExportRequest>, options: Option<OperationTemplatesLroClientBeginExportOptions<'_>>) -> Result<Poller<ExportResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut url = self.endpoint.clone();
        let mut path = String::from("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Azure.ResourceManager.OperationTemplates/orders/{orderName}/export");
        path = path.replace("{orderName}", order_name);
        path = path.replace("{resourceGroupName}", resource_group_name);
        path = path.replace("{subscriptionId}", &self.subscription_id);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);


        let api_version = self.api_version.clone();

        Ok(Poller::from_callback(
            move |next_link: PollerState<Url>| {
                let (mut request, next_link) = match next_link {
                    PollerState::More(next_link) => {
                        let qp = next_link.query_pairs().filter(|(name, _)| name.ne("api-version"));
                        let mut next_link = next_link.clone();
                        next_link.query_pairs_mut().clear().extend_pairs(qp).append_pair("api-version", &api_version);

                        let mut request = Request::new(next_link.clone(), Method::Get);
                        request.insert_header("accept", "application/json");
                        request.insert_header("content-type", "application/json");


                        (request, next_link)
                    },
                    PollerState::Initial => {
                        let mut request = Request::new(url.clone(), Method::Post);
                        request.insert_header("accept", "application/json");
                        request.insert_header("content-type", "application/json");
                        request.set_body(body.clone());

                        (request, url.clone())
                    },
                };

                let ctx = options.method_options.context.clone();
                let pipeline = pipeline.clone();
                async move {
                    let rsp: RawResponse = pipeline.send(&ctx, &mut request).await?;
                    let (status, headers, body) = rsp.deconstruct();
                    let retry_after = get_retry_after(&headers, &options.poller_options);
                    let bytes = body.collect().await?;
                    let res: ExportResult = json::from_json(&bytes)?;
                    let rsp = RawResponse::from_bytes(status, headers, bytes).into();
                    Ok(match res.status() {
                        PollerStatus::InProgress => PollerResult::InProgress {
                            response: rsp, retry_after, next: next_link
                        },
                        _ => PollerResult::Done {
                            response: rsp                        },
                    })
                }
            },
            None,
        ))
    }

    /// Delete a Order
    ///
    /// # Arguments
    ///
/// * `resource_group_name` - The name of the resource group. The name is case insensitive.
/// * `order_name` - The name of the Order
/// * `options` - Optional parameters for the request.
    #[tracing::function("OperationTemplatesLro.ArmOperationStatusResourceProvisioningState.resume")]
    pub fn resume_arm_operation_status_resource_provisioning_state_operation(&self, resource_group_name: &str, order_name: &str, options: Option<OperationTemplatesLroClientResumeArmOperationStatusResourceProvisioningStateOperationOptions<'_>>) -> Result<Poller<ArmOperationStatusResourceProvisioningState>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut url = self.endpoint.clone();
        let mut path = String::from("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Azure.ResourceManager.OperationTemplates/orders/{orderName}");
        path = path.replace("{orderName}", order_name);
        path = path.replace("{resourceGroupName}", resource_group_name);
        path = path.replace("{subscriptionId}", &self.subscription_id);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        Ok(Poller::from_callback(
            move |_| {
                let url = url.clone();
                let mut request = Request::new(url.clone(), Method::Get);

                let ctx = options.method_options.context.clone();
                let pipeline = pipeline.clone();
                async move {
                    let rsp: RawResponse = pipeline.send(&ctx, &mut request).await?;
                    let (status, headers, body) = rsp.deconstruct();
                    let retry_after = get_retry_after(&headers, &options.poller_options);
                    let bytes = body.collect().await?;
                    let res: ArmOperationStatusResourceProvisioningState = json::from_json(&bytes)?;
                    let rsp = RawResponse::from_bytes(status, headers, bytes).into();

                    Ok(match res.status() {
                        PollerStatus::InProgress => PollerResult::InProgress {
                            response: rsp, retry_after, next: url
                        },
                        _ => PollerResult::Done {
                            response: rsp                        },
                    })                }
            },
            None,
        ))
    }

    /// A long-running resource action.
    ///
    /// # Arguments
    ///
/// * `resource_group_name` - The name of the resource group. The name is case insensitive.
/// * `order_name` - The name of the Order
/// * `options` - Optional parameters for the request.
    #[tracing::function("OperationTemplatesLro.ExportResult.resume")]
    pub fn resume_export_result_operation(&self, resource_group_name: &str, order_name: &str, options: Option<OperationTemplatesLroClientResumeExportResultOperationOptions<'_>>) -> Result<Poller<ExportResult>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut url = self.endpoint.clone();
        let mut path = String::from("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Azure.ResourceManager.OperationTemplates/orders/{orderName}/export");
        path = path.replace("{orderName}", order_name);
        path = path.replace("{resourceGroupName}", resource_group_name);
        path = path.replace("{subscriptionId}", &self.subscription_id);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        Ok(Poller::from_callback(
            move |_| {
                let url = url.clone();
                let mut request = Request::new(url.clone(), Method::Get);
                request.insert_header("accept", "application/json");
                request.insert_header("content-type", "application/json");

                let ctx = options.method_options.context.clone();
                let pipeline = pipeline.clone();
                async move {
                    let rsp: RawResponse = pipeline.send(&ctx, &mut request).await?;
                    let (status, headers, body) = rsp.deconstruct();
                    let retry_after = get_retry_after(&headers, &options.poller_options);
                    let bytes = body.collect().await?;
                    let res: ExportResult = json::from_json(&bytes)?;
                    let rsp = RawResponse::from_bytes(status, headers, bytes).into();

                    Ok(match res.status() {
                        PollerStatus::InProgress => PollerResult::InProgress {
                            response: rsp, retry_after, next: url
                        },
                        _ => PollerResult::Done {
                            response: rsp                        },
                    })                }
            },
            None,
        ))
    }

    /// Create a Order
    ///
    /// # Arguments
    ///
/// * `resource_group_name` - The name of the resource group. The name is case insensitive.
/// * `order_name` - The name of the Order
/// * `options` - Optional parameters for the request.
    #[tracing::function("OperationTemplatesLro.Order.resume")]
    pub fn resume_order_operation(&self, resource_group_name: &str, order_name: &str, options: Option<OperationTemplatesLroClientResumeOrderOperationOptions<'_>>) -> Result<Poller<Order>> {
        let options = options.unwrap_or_default().into_owned();
        let pipeline = self.pipeline.clone();
        let mut url = self.endpoint.clone();
        let mut path = String::from("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Azure.ResourceManager.OperationTemplates/orders/{orderName}");
        path = path.replace("{orderName}", order_name);
        path = path.replace("{resourceGroupName}", resource_group_name);
        path = path.replace("{subscriptionId}", &self.subscription_id);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("api-version", &self.api_version);
        Ok(Poller::from_callback(
            move |_| {
                let url = url.clone();
                let mut request = Request::new(url.clone(), Method::Get);
                request.insert_header("accept", "application/json");
                request.insert_header("content-type", "application/json");

                let ctx = options.method_options.context.clone();
                let pipeline = pipeline.clone();
                async move {
                    let rsp: RawResponse = pipeline.send(&ctx, &mut request).await?;
                    let (status, headers, body) = rsp.deconstruct();
                    let retry_after = get_retry_after(&headers, &options.poller_options);
                    let bytes = body.collect().await?;
                    let res: Order = json::from_json(&bytes)?;
                    let rsp = RawResponse::from_bytes(status, headers, bytes).into();

                    Ok(match res.status() {
                        PollerStatus::InProgress => PollerResult::InProgress {
                            response: rsp, retry_after, next: url
                        },
                        _ => PollerResult::Done {
                            response: rsp                        },
                    })                }
            },
            None,
        ))
    }
}


