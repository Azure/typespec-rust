// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use super::{
    models_serde,
    xml_helpers::{ColorsString, CountsInt32, ItemsSimpleModel},
    Status,
};
use azure_core::{fmt::SafeDebug, time::OffsetDateTime};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Contains an array of models.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ModelWithArrayOfModel {
    #[serde(
        default,
        deserialize_with = "ItemsSimpleModel::unwrap",
        serialize_with = "ItemsSimpleModel::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub items: Option<Vec<SimpleModel>>,
}

/// Contains fields that are XML attributes.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ModelWithAttributes {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,

    #[serde(rename = "@id1", skip_serializing_if = "Option::is_none")]
    pub id1: Option<i32>,

    #[serde(rename = "@id2", skip_serializing_if = "Option::is_none")]
    pub id2: Option<String>,
}

/// Contains datetime properties with different encodings.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ModelWithDatetime {
    /// DateTime value with rfc3339 encoding.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        with = "models_serde::option_offset_date_time_rfc3339"
    )]
    pub rfc3339: Option<OffsetDateTime>,

    /// DateTime value with rfc7231 encoding.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        with = "azure_core::time::rfc7231::option"
    )]
    pub rfc7231: Option<OffsetDateTime>,
}

/// Contains a dictionary of key value pairs.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ModelWithDictionary {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
}

/// Contains an array of models that's supposed to be sent/received as an empty XML element.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ModelWithEmptyArray {
    #[serde(
        default,
        deserialize_with = "ItemsSimpleModel::unwrap",
        serialize_with = "ItemsSimpleModel::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub items: Option<Vec<SimpleModel>>,
}

/// Uses encodedName instead of Xml.Name which is functionally equivalent.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[serde(rename = "ModelWithEncodedNamesSrc")]
pub struct ModelWithEncodedNames {
    #[serde(
        default,
        deserialize_with = "ColorsString::unwrap",
        rename = "PossibleColors",
        serialize_with = "ColorsString::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub colors: Option<Vec<String>>,

    #[serde(rename = "SimpleModelData", skip_serializing_if = "Option::is_none")]
    pub model_data: Option<SimpleModel>,
}

/// Contains a single property with an enum value.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ModelWithEnum {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<Status>,
}

/// Contains an optional field.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ModelWithOptionalField {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub item: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<i32>,
}

/// Contains fields of wrapped and unwrapped arrays of primitive types that have different XML representations.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ModelWithRenamedArrays {
    #[serde(rename = "Colors", skip_serializing_if = "Option::is_none")]
    pub colors: Option<Vec<String>>,

    #[serde(
        default,
        deserialize_with = "CountsInt32::unwrap",
        rename = "Counts",
        serialize_with = "CountsInt32::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub counts: Option<Vec<i32>>,
}

/// Contains fields of the same type that have different XML representation.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[serde(rename = "ModelWithRenamedFieldsSrc")]
pub struct ModelWithRenamedFields {
    #[serde(rename = "InputData", skip_serializing_if = "Option::is_none")]
    pub input_data: Option<SimpleModel>,

    #[serde(rename = "OutputData", skip_serializing_if = "Option::is_none")]
    pub output_data: Option<SimpleModel>,
}

/// Contains fields of arrays of primitive types.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ModelWithSimpleArrays {
    #[serde(
        default,
        deserialize_with = "ColorsString::unwrap",
        serialize_with = "ColorsString::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub colors: Option<Vec<String>>,

    #[serde(
        default,
        deserialize_with = "CountsInt32::unwrap",
        serialize_with = "CountsInt32::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub counts: Option<Vec<i32>>,
}

/// Contains an attribute and text.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ModelWithText {
    #[serde(rename = "$text", skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,

    #[serde(rename = "@language", skip_serializing_if = "Option::is_none")]
    pub language: Option<String>,
}

/// Contains fields of wrapped and unwrapped arrays of primitive types.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct ModelWithUnwrappedArray {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub colors: Option<Vec<String>>,

    #[serde(
        default,
        deserialize_with = "CountsInt32::unwrap",
        serialize_with = "CountsInt32::wrap",
        skip_serializing_if = "Option::is_none"
    )]
    pub counts: Option<Vec<i32>>,
}

/// Contains fields of primitive types.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
pub struct SimpleModel {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub age: Option<i32>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// The body of an XML error response.
#[derive(Clone, Default, Deserialize, SafeDebug, Serialize)]
#[non_exhaustive]
pub struct XmlErrorBody {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<i32>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
