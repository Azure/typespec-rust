// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use super::{
    And, As, Assert, Async, Await, Break, Class, Constructor, Continue, Def, Del, Elif, Else,
    Except, Exec, Finally, For, From, Global, If, Import, In, Is, Lambda, Not, Or, Pass, Raise,
    Return, SameAsModel, Try, While, With, Yield,
};
use azure_core::{http::RequestContent, json::to_json, Result};

impl TryFrom<And> for RequestContent<And> {
    type Error = azure_core::Error;
    fn try_from(value: And) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<As> for RequestContent<As> {
    type Error = azure_core::Error;
    fn try_from(value: As) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Assert> for RequestContent<Assert> {
    type Error = azure_core::Error;
    fn try_from(value: Assert) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Async> for RequestContent<Async> {
    type Error = azure_core::Error;
    fn try_from(value: Async) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Await> for RequestContent<Await> {
    type Error = azure_core::Error;
    fn try_from(value: Await) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Break> for RequestContent<Break> {
    type Error = azure_core::Error;
    fn try_from(value: Break) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Class> for RequestContent<Class> {
    type Error = azure_core::Error;
    fn try_from(value: Class) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Constructor> for RequestContent<Constructor> {
    type Error = azure_core::Error;
    fn try_from(value: Constructor) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Continue> for RequestContent<Continue> {
    type Error = azure_core::Error;
    fn try_from(value: Continue) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Def> for RequestContent<Def> {
    type Error = azure_core::Error;
    fn try_from(value: Def) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Del> for RequestContent<Del> {
    type Error = azure_core::Error;
    fn try_from(value: Del) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Elif> for RequestContent<Elif> {
    type Error = azure_core::Error;
    fn try_from(value: Elif) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Else> for RequestContent<Else> {
    type Error = azure_core::Error;
    fn try_from(value: Else) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Except> for RequestContent<Except> {
    type Error = azure_core::Error;
    fn try_from(value: Except) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Exec> for RequestContent<Exec> {
    type Error = azure_core::Error;
    fn try_from(value: Exec) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Finally> for RequestContent<Finally> {
    type Error = azure_core::Error;
    fn try_from(value: Finally) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<For> for RequestContent<For> {
    type Error = azure_core::Error;
    fn try_from(value: For) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<From> for RequestContent<From> {
    type Error = azure_core::Error;
    fn try_from(value: From) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Global> for RequestContent<Global> {
    type Error = azure_core::Error;
    fn try_from(value: Global) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<If> for RequestContent<If> {
    type Error = azure_core::Error;
    fn try_from(value: If) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Import> for RequestContent<Import> {
    type Error = azure_core::Error;
    fn try_from(value: Import) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<In> for RequestContent<In> {
    type Error = azure_core::Error;
    fn try_from(value: In) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Is> for RequestContent<Is> {
    type Error = azure_core::Error;
    fn try_from(value: Is) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Lambda> for RequestContent<Lambda> {
    type Error = azure_core::Error;
    fn try_from(value: Lambda) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Not> for RequestContent<Not> {
    type Error = azure_core::Error;
    fn try_from(value: Not) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Or> for RequestContent<Or> {
    type Error = azure_core::Error;
    fn try_from(value: Or) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Pass> for RequestContent<Pass> {
    type Error = azure_core::Error;
    fn try_from(value: Pass) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Raise> for RequestContent<Raise> {
    type Error = azure_core::Error;
    fn try_from(value: Raise) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Return> for RequestContent<Return> {
    type Error = azure_core::Error;
    fn try_from(value: Return) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<SameAsModel> for RequestContent<SameAsModel> {
    type Error = azure_core::Error;
    fn try_from(value: SameAsModel) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Try> for RequestContent<Try> {
    type Error = azure_core::Error;
    fn try_from(value: Try) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<While> for RequestContent<While> {
    type Error = azure_core::Error;
    fn try_from(value: While) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<With> for RequestContent<With> {
    type Error = azure_core::Error;
    fn try_from(value: With) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}

impl TryFrom<Yield> for RequestContent<Yield> {
    type Error = azure_core::Error;
    fn try_from(value: Yield) -> Result<Self> {
        Ok(to_json(&value)?.into())
    }
}
